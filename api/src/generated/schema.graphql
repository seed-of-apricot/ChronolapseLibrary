### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type AggregateCity {
  count: Int!
}

type AggregateCivic {
  count: Int!
}

type AggregateGame {
  count: Int!
}

type AggregateLeader {
  count: Int!
}

type AggregateMap {
  count: Int!
}

type AggregatePlayer {
  count: Int!
}

type AggregateTech {
  count: Int!
}

type AggregateTile {
  count: Int!
}

type AggregateUnit {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type BooleanTS {
  time: DateTime!
  value: Boolean!
}

input BooleanTSCreateInput {
  value: Boolean!
}

input BooleanTSCreateManyInput {
  create: [BooleanTSCreateInput!]
}

input BooleanTSRestrictedWhereInput {
  AND: [BooleanTSRestrictedWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Boolean
  value_not: Boolean
}

input BooleanTSScalarWhereInput {
  AND: [BooleanTSScalarWhereInput!]
  NOT: [BooleanTSScalarWhereInput!]
  OR: [BooleanTSScalarWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Boolean
  value_not: Boolean
}

input BooleanTSUpdateManyDataInput {
  value: Boolean
}

input BooleanTSUpdateManyInput {
  create: [BooleanTSCreateInput!]
  deleteMany: [BooleanTSScalarWhereInput!]
  updateMany: [BooleanTSUpdateManyWithWhereNestedInput!]
}

input BooleanTSUpdateManyWithWhereNestedInput {
  data: BooleanTSUpdateManyDataInput!
  where: BooleanTSScalarWhereInput!
}

input BooleanTSWhereInput {
  AND: [BooleanTSWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Boolean
  value_not: Boolean
}

type City {
  amenity: [IntTS!]
  entertainment: [IntTS!]
  id: ID!
  isExist: [BooleanTS!]
  location: [TileTS!]
  name: [StringTS!]
  population: [IntTS!]
}

type CityConnection {
  aggregate: AggregateCity!
  edges: [CityEdge!]!
  pageInfo: PageInfo!
}

input CityCreateInput {
  amenity: IntTSCreateManyInput
  entertainment: IntTSCreateManyInput
  id: ID
  isExist: BooleanTSCreateManyInput
  location: TileTSCreateManyInput
  name: StringTSCreateManyInput
  population: IntTSCreateManyInput
}

input CityCreateManyInput {
  connect: [CityWhereUniqueInput!]
  create: [CityCreateInput!]
}

type CityEdge {
  cursor: String!
  node: City!
}

enum CityOrderByInput {
  id_ASC
  id_DESC
}

input CityScalarWhereInput {
  AND: [CityScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [CityScalarWhereInput!]
  OR: [CityScalarWhereInput!]
}

input CityUpdateDataInput {
  amenity: IntTSUpdateManyInput
  entertainment: IntTSUpdateManyInput
  isExist: BooleanTSUpdateManyInput
  location: TileTSUpdateManyInput
  name: StringTSUpdateManyInput
  population: IntTSUpdateManyInput
}

input CityUpdateInput {
  amenity: IntTSUpdateManyInput
  entertainment: IntTSUpdateManyInput
  isExist: BooleanTSUpdateManyInput
  location: TileTSUpdateManyInput
  name: StringTSUpdateManyInput
  population: IntTSUpdateManyInput
}

input CityUpdateManyInput {
  connect: [CityWhereUniqueInput!]
  create: [CityCreateInput!]
  delete: [CityWhereUniqueInput!]
  deleteMany: [CityScalarWhereInput!]
  disconnect: [CityWhereUniqueInput!]
  set: [CityWhereUniqueInput!]
  update: [CityUpdateWithWhereUniqueNestedInput!]
  upsert: [CityUpsertWithWhereUniqueNestedInput!]
}

input CityUpdateWithWhereUniqueNestedInput {
  data: CityUpdateDataInput!
  where: CityWhereUniqueInput!
}

input CityUpsertWithWhereUniqueNestedInput {
  create: CityCreateInput!
  update: CityUpdateDataInput!
  where: CityWhereUniqueInput!
}

input CityWhereInput {
  amenity_every: IntTSRestrictedWhereInput
  amenity_none: IntTSRestrictedWhereInput
  amenity_some: IntTSWhereInput
  AND: [CityWhereInput!]
  entertainment_every: IntTSRestrictedWhereInput
  entertainment_none: IntTSRestrictedWhereInput
  entertainment_some: IntTSWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isExist_every: BooleanTSRestrictedWhereInput
  isExist_none: BooleanTSRestrictedWhereInput
  isExist_some: BooleanTSWhereInput
  location_every: TileTSRestrictedWhereInput
  location_none: TileTSRestrictedWhereInput
  location_some: TileTSWhereInput
  name_every: StringTSRestrictedWhereInput
  name_none: StringTSRestrictedWhereInput
  name_some: StringTSWhereInput
  population_every: IntTSRestrictedWhereInput
  population_none: IntTSRestrictedWhereInput
  population_some: IntTSWhereInput
}

input CityWhereUniqueInput {
  id: ID
}

type Civic {
  boosted: [BooleanTS!]
  cost: Int!
  id: ID!
  progress: [FloatTS!]
  type: Int!
}

type CivicConnection {
  aggregate: AggregateCivic!
  edges: [CivicEdge!]!
  pageInfo: PageInfo!
}

input CivicCreateInput {
  boosted: BooleanTSCreateManyInput
  cost: Int!
  id: ID
  progress: FloatTSCreateManyInput
  type: Int!
}

input CivicCreateManyInput {
  connect: [CivicWhereUniqueInput!]
  create: [CivicCreateInput!]
}

type CivicEdge {
  cursor: String!
  node: Civic!
}

enum CivicOrderByInput {
  cost_ASC
  cost_DESC
  id_ASC
  id_DESC
  type_ASC
  type_DESC
}

input CivicScalarWhereInput {
  AND: [CivicScalarWhereInput!]
  cost: Int
  cost_gt: Int
  cost_gte: Int
  cost_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_not: Int
  cost_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [CivicScalarWhereInput!]
  OR: [CivicScalarWhereInput!]
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
}

input CivicUpdateDataInput {
  boosted: BooleanTSUpdateManyInput
  cost: Int
  progress: FloatTSUpdateManyInput
  type: Int
}

input CivicUpdateInput {
  boosted: BooleanTSUpdateManyInput
  cost: Int
  progress: FloatTSUpdateManyInput
  type: Int
}

input CivicUpdateManyDataInput {
  cost: Int
  type: Int
}

input CivicUpdateManyInput {
  connect: [CivicWhereUniqueInput!]
  create: [CivicCreateInput!]
  delete: [CivicWhereUniqueInput!]
  deleteMany: [CivicScalarWhereInput!]
  disconnect: [CivicWhereUniqueInput!]
  set: [CivicWhereUniqueInput!]
  update: [CivicUpdateWithWhereUniqueNestedInput!]
  updateMany: [CivicUpdateManyWithWhereNestedInput!]
  upsert: [CivicUpsertWithWhereUniqueNestedInput!]
}

input CivicUpdateManyMutationInput {
  cost: Int
  type: Int
}

input CivicUpdateManyWithWhereNestedInput {
  data: CivicUpdateManyDataInput!
  where: CivicScalarWhereInput!
}

input CivicUpdateWithWhereUniqueNestedInput {
  data: CivicUpdateDataInput!
  where: CivicWhereUniqueInput!
}

input CivicUpsertWithWhereUniqueNestedInput {
  create: CivicCreateInput!
  update: CivicUpdateDataInput!
  where: CivicWhereUniqueInput!
}

input CivicWhereInput {
  AND: [CivicWhereInput!]
  boosted_every: BooleanTSRestrictedWhereInput
  boosted_none: BooleanTSRestrictedWhereInput
  boosted_some: BooleanTSWhereInput
  cost: Int
  cost_gt: Int
  cost_gte: Int
  cost_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_not: Int
  cost_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  progress_every: FloatTSRestrictedWhereInput
  progress_none: FloatTSRestrictedWhereInput
  progress_some: FloatTSWhereInput
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
}

input CivicWhereUniqueInput {
  id: ID
}

scalar DateTime

type FloatTS {
  time: DateTime!
  value: Float!
}

input FloatTSCreateInput {
  value: Float!
}

input FloatTSCreateManyInput {
  create: [FloatTSCreateInput!]
}

input FloatTSRestrictedWhereInput {
  AND: [FloatTSRestrictedWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Float
  value_gt: Float
  value_gte: Float
  value_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_not: Float
  value_not_in: [Float!]
}

input FloatTSScalarWhereInput {
  AND: [FloatTSScalarWhereInput!]
  NOT: [FloatTSScalarWhereInput!]
  OR: [FloatTSScalarWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Float
  value_gt: Float
  value_gte: Float
  value_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_not: Float
  value_not_in: [Float!]
}

input FloatTSUpdateManyDataInput {
  value: Float
}

input FloatTSUpdateManyInput {
  create: [FloatTSCreateInput!]
  deleteMany: [FloatTSScalarWhereInput!]
  updateMany: [FloatTSUpdateManyWithWhereNestedInput!]
}

input FloatTSUpdateManyWithWhereNestedInput {
  data: FloatTSUpdateManyDataInput!
  where: FloatTSScalarWhereInput!
}

input FloatTSWhereInput {
  AND: [FloatTSWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Float
  value_gt: Float
  value_gte: Float
  value_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_not: Float
  value_not_in: [Float!]
}

type Game {
  id: ID!
  leaders(after: String, before: String, first: Int, last: Int, orderBy: LeaderOrderByInput, skip: Int, where: LeaderWhereInput): [Leader!]
  map: Map!
  name: String!
}

type GameConnection {
  aggregate: AggregateGame!
  edges: [GameEdge!]!
  pageInfo: PageInfo!
}

input GameCreateInput {
  id: ID
  leaders: LeaderCreateManyInput
  map: MapCreateOneInput!
  name: String!
}

type GameEdge {
  cursor: String!
  node: Game!
}

enum GameOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

input GameUpdateInput {
  leaders: LeaderUpdateManyInput
  map: MapUpdateOneRequiredInput
  name: String
}

input GameUpdateManyMutationInput {
  name: String
}

input GameWhereInput {
  AND: [GameWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  leaders_some: LeaderWhereInput
  map: MapWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
}

input GameWhereUniqueInput {
  id: ID
}

type IntTS {
  time: DateTime!
  value: Int!
}

input IntTSCreateInput {
  value: Int!
}

input IntTSCreateManyInput {
  create: [IntTSCreateInput!]
}

input IntTSRestrictedWhereInput {
  AND: [IntTSRestrictedWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Int
  value_gt: Int
  value_gte: Int
  value_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_not: Int
  value_not_in: [Int!]
}

input IntTSScalarWhereInput {
  AND: [IntTSScalarWhereInput!]
  NOT: [IntTSScalarWhereInput!]
  OR: [IntTSScalarWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Int
  value_gt: Int
  value_gte: Int
  value_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_not: Int
  value_not_in: [Int!]
}

input IntTSUpdateManyDataInput {
  value: Int
}

input IntTSUpdateManyInput {
  create: [IntTSCreateInput!]
  deleteMany: [IntTSScalarWhereInput!]
  updateMany: [IntTSUpdateManyWithWhereNestedInput!]
}

input IntTSUpdateManyWithWhereNestedInput {
  data: IntTSUpdateManyDataInput!
  where: IntTSScalarWhereInput!
}

input IntTSWhereInput {
  AND: [IntTSWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: Int
  value_gt: Int
  value_gte: Int
  value_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_not: Int
  value_not_in: [Int!]
}

type Leader {
  cities(after: String, before: String, first: Int, last: Int, orderBy: CityOrderByInput, skip: Int, where: CityWhereInput): [City!]
  civics(after: String, before: String, first: Int, last: Int, orderBy: CivicOrderByInput, skip: Int, where: CivicWhereInput): [Civic!]
  id: ID!
  name: String!
  player: Player!
  techs(after: String, before: String, first: Int, last: Int, orderBy: TechOrderByInput, skip: Int, where: TechWhereInput): [Tech!]
  units(after: String, before: String, first: Int, last: Int, orderBy: UnitOrderByInput, skip: Int, where: UnitWhereInput): [Unit!]
}

type LeaderConnection {
  aggregate: AggregateLeader!
  edges: [LeaderEdge!]!
  pageInfo: PageInfo!
}

input LeaderCreateInput {
  cities: CityCreateManyInput
  civics: CivicCreateManyInput
  id: ID
  name: String!
  player: PlayerCreateOneInput!
  techs: TechCreateManyInput
  units: UnitCreateManyInput
}

input LeaderCreateManyInput {
  connect: [LeaderWhereUniqueInput!]
  create: [LeaderCreateInput!]
}

type LeaderEdge {
  cursor: String!
  node: Leader!
}

enum LeaderOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

input LeaderScalarWhereInput {
  AND: [LeaderScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [LeaderScalarWhereInput!]
  OR: [LeaderScalarWhereInput!]
}

input LeaderUpdateDataInput {
  cities: CityUpdateManyInput
  civics: CivicUpdateManyInput
  name: String
  player: PlayerUpdateOneRequiredInput
  techs: TechUpdateManyInput
  units: UnitUpdateManyInput
}

input LeaderUpdateInput {
  cities: CityUpdateManyInput
  civics: CivicUpdateManyInput
  name: String
  player: PlayerUpdateOneRequiredInput
  techs: TechUpdateManyInput
  units: UnitUpdateManyInput
}

input LeaderUpdateManyDataInput {
  name: String
}

input LeaderUpdateManyInput {
  connect: [LeaderWhereUniqueInput!]
  create: [LeaderCreateInput!]
  delete: [LeaderWhereUniqueInput!]
  deleteMany: [LeaderScalarWhereInput!]
  disconnect: [LeaderWhereUniqueInput!]
  set: [LeaderWhereUniqueInput!]
  update: [LeaderUpdateWithWhereUniqueNestedInput!]
  updateMany: [LeaderUpdateManyWithWhereNestedInput!]
  upsert: [LeaderUpsertWithWhereUniqueNestedInput!]
}

input LeaderUpdateManyMutationInput {
  name: String
}

input LeaderUpdateManyWithWhereNestedInput {
  data: LeaderUpdateManyDataInput!
  where: LeaderScalarWhereInput!
}

input LeaderUpdateWithWhereUniqueNestedInput {
  data: LeaderUpdateDataInput!
  where: LeaderWhereUniqueInput!
}

input LeaderUpsertWithWhereUniqueNestedInput {
  create: LeaderCreateInput!
  update: LeaderUpdateDataInput!
  where: LeaderWhereUniqueInput!
}

input LeaderWhereInput {
  AND: [LeaderWhereInput!]
  cities_some: CityWhereInput
  civics_some: CivicWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  player: PlayerWhereInput
  techs_some: TechWhereInput
  units_some: UnitWhereInput
}

input LeaderWhereUniqueInput {
  id: ID
}

scalar Long

type Map {
  id: ID!
  tiles(after: String, before: String, first: Int, last: Int, orderBy: TileOrderByInput, skip: Int, where: TileWhereInput): [Tile!]
  type: String!
}

type MapConnection {
  aggregate: AggregateMap!
  edges: [MapEdge!]!
  pageInfo: PageInfo!
}

input MapCreateInput {
  id: ID
  tiles: TileCreateManyInput
  type: String!
}

input MapCreateOneInput {
  connect: MapWhereUniqueInput
  create: MapCreateInput
}

type MapEdge {
  cursor: String!
  node: Map!
}

enum MapOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
}

input MapUpdateDataInput {
  tiles: TileUpdateManyInput
  type: String
}

input MapUpdateInput {
  tiles: TileUpdateManyInput
  type: String
}

input MapUpdateManyMutationInput {
  type: String
}

input MapUpdateOneRequiredInput {
  connect: MapWhereUniqueInput
  create: MapCreateInput
  update: MapUpdateDataInput
  upsert: MapUpsertNestedInput
}

input MapUpsertNestedInput {
  create: MapCreateInput!
  update: MapUpdateDataInput!
}

input MapWhereInput {
  AND: [MapWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  tiles_some: TileWhereInput
  type: String
  type_contains: String
  type_ends_with: String
  type_gt: String
  type_gte: String
  type_in: [String!]
  type_lt: String
  type_lte: String
  type_not: String
  type_not_contains: String
  type_not_ends_with: String
  type_not_in: [String!]
  type_not_starts_with: String
  type_starts_with: String
}

input MapWhereUniqueInput {
  id: ID
}

type Mutation {
  createCity(data: CityCreateInput!): City!
  createCivic(data: CivicCreateInput!): Civic!
  createGame(data: GameCreateInput!): Game!
  createLeader(data: LeaderCreateInput!): Leader!
  createMap(data: MapCreateInput!): Map!
  createPlayer(data: PlayerCreateInput!): Player!
  createTech(data: TechCreateInput!): Tech!
  createTile(data: TileCreateInput!): Tile!
  createUnit(data: UnitCreateInput!): Unit!
  deleteCity(where: CityWhereUniqueInput!): City
  deleteCivic(where: CivicWhereUniqueInput!): Civic
  deleteGame(where: GameWhereUniqueInput!): Game
  deleteLeader(where: LeaderWhereUniqueInput!): Leader
  deleteManyCities(where: CityWhereInput): BatchPayload!
  deleteManyCivics(where: CivicWhereInput): BatchPayload!
  deleteManyGames(where: GameWhereInput): BatchPayload!
  deleteManyLeaders(where: LeaderWhereInput): BatchPayload!
  deleteManyMaps(where: MapWhereInput): BatchPayload!
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  deleteManyTeches(where: TechWhereInput): BatchPayload!
  deleteManyTiles(where: TileWhereInput): BatchPayload!
  deleteManyUnits(where: UnitWhereInput): BatchPayload!
  deleteMap(where: MapWhereUniqueInput!): Map
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteTech(where: TechWhereUniqueInput!): Tech
  deleteTile(where: TileWhereUniqueInput!): Tile
  deleteUnit(where: UnitWhereUniqueInput!): Unit
  updateCity(data: CityUpdateInput!, where: CityWhereUniqueInput!): City
  updateCivic(data: CivicUpdateInput!, where: CivicWhereUniqueInput!): Civic
  updateGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateLeader(data: LeaderUpdateInput!, where: LeaderWhereUniqueInput!): Leader
  updateManyCivics(data: CivicUpdateManyMutationInput!, where: CivicWhereInput): BatchPayload!
  updateManyGames(data: GameUpdateManyMutationInput!, where: GameWhereInput): BatchPayload!
  updateManyLeaders(data: LeaderUpdateManyMutationInput!, where: LeaderWhereInput): BatchPayload!
  updateManyMaps(data: MapUpdateManyMutationInput!, where: MapWhereInput): BatchPayload!
  updateManyTeches(data: TechUpdateManyMutationInput!, where: TechWhereInput): BatchPayload!
  updateManyTiles(data: TileUpdateManyMutationInput!, where: TileWhereInput): BatchPayload!
  updateManyUnits(data: UnitUpdateManyMutationInput!, where: UnitWhereInput): BatchPayload!
  updateMap(data: MapUpdateInput!, where: MapWhereUniqueInput!): Map
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  updateTech(data: TechUpdateInput!, where: TechWhereUniqueInput!): Tech
  updateTile(data: TileUpdateInput!, where: TileWhereUniqueInput!): Tile
  updateUnit(data: UnitUpdateInput!, where: UnitWhereUniqueInput!): Unit
  upsertCity(create: CityCreateInput!, update: CityUpdateInput!, where: CityWhereUniqueInput!): City!
  upsertCivic(create: CivicCreateInput!, update: CivicUpdateInput!, where: CivicWhereUniqueInput!): Civic!
  upsertGame(create: GameCreateInput!, update: GameUpdateInput!, where: GameWhereUniqueInput!): Game!
  upsertLeader(create: LeaderCreateInput!, update: LeaderUpdateInput!, where: LeaderWhereUniqueInput!): Leader!
  upsertMap(create: MapCreateInput!, update: MapUpdateInput!, where: MapWhereUniqueInput!): Map!
  upsertPlayer(create: PlayerCreateInput!, update: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player!
  upsertTech(create: TechCreateInput!, update: TechUpdateInput!, where: TechWhereUniqueInput!): Tech!
  upsertTile(create: TileCreateInput!, update: TileUpdateInput!, where: TileWhereUniqueInput!): Tile!
  upsertUnit(create: UnitCreateInput!, update: UnitUpdateInput!, where: UnitWhereUniqueInput!): Unit!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Player {
  id: ID!
  isHuman: [BooleanTS!]
  name: [StringTS!]
}

type PlayerConnection {
  aggregate: AggregatePlayer!
  edges: [PlayerEdge!]!
  pageInfo: PageInfo!
}

input PlayerCreateInput {
  id: ID
  isHuman: BooleanTSCreateManyInput
  name: StringTSCreateManyInput
}

input PlayerCreateOneInput {
  connect: PlayerWhereUniqueInput
  create: PlayerCreateInput
}

type PlayerEdge {
  cursor: String!
  node: Player!
}

enum PlayerOrderByInput {
  id_ASC
  id_DESC
}

input PlayerUpdateDataInput {
  isHuman: BooleanTSUpdateManyInput
  name: StringTSUpdateManyInput
}

input PlayerUpdateInput {
  isHuman: BooleanTSUpdateManyInput
  name: StringTSUpdateManyInput
}

input PlayerUpdateOneRequiredInput {
  connect: PlayerWhereUniqueInput
  create: PlayerCreateInput
  update: PlayerUpdateDataInput
  upsert: PlayerUpsertNestedInput
}

input PlayerUpsertNestedInput {
  create: PlayerCreateInput!
  update: PlayerUpdateDataInput!
}

input PlayerWhereInput {
  AND: [PlayerWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isHuman_every: BooleanTSRestrictedWhereInput
  isHuman_none: BooleanTSRestrictedWhereInput
  isHuman_some: BooleanTSWhereInput
  name_every: StringTSRestrictedWhereInput
  name_none: StringTSRestrictedWhereInput
  name_some: StringTSWhereInput
}

input PlayerWhereUniqueInput {
  id: ID
}

type Query {
  cities(after: String, before: String, first: Int, last: Int, orderBy: CityOrderByInput, skip: Int, where: CityWhereInput): [City!]!
  citiesConnection(after: String, before: String, first: Int, last: Int, orderBy: CityOrderByInput, skip: Int, where: CityWhereInput): CityConnection!
  city(where: CityWhereUniqueInput!): City
  civic(where: CivicWhereUniqueInput!): Civic
  civics(after: String, before: String, first: Int, last: Int, orderBy: CivicOrderByInput, skip: Int, where: CivicWhereInput): [Civic!]!
  civicsConnection(after: String, before: String, first: Int, last: Int, orderBy: CivicOrderByInput, skip: Int, where: CivicWhereInput): CivicConnection!
  game(where: GameWhereUniqueInput!): Game
  games(after: String, before: String, first: Int, last: Int, orderBy: GameOrderByInput, skip: Int, where: GameWhereInput): [Game!]!
  gamesConnection(after: String, before: String, first: Int, last: Int, orderBy: GameOrderByInput, skip: Int, where: GameWhereInput): GameConnection!
  leader(where: LeaderWhereUniqueInput!): Leader
  leaders(after: String, before: String, first: Int, last: Int, orderBy: LeaderOrderByInput, skip: Int, where: LeaderWhereInput): [Leader!]!
  leadersConnection(after: String, before: String, first: Int, last: Int, orderBy: LeaderOrderByInput, skip: Int, where: LeaderWhereInput): LeaderConnection!
  map(where: MapWhereUniqueInput!): Map
  maps(after: String, before: String, first: Int, last: Int, orderBy: MapOrderByInput, skip: Int, where: MapWhereInput): [Map!]!
  mapsConnection(after: String, before: String, first: Int, last: Int, orderBy: MapOrderByInput, skip: Int, where: MapWhereInput): MapConnection!
  player(where: PlayerWhereUniqueInput!): Player
  players(after: String, before: String, first: Int, last: Int, orderBy: PlayerOrderByInput, skip: Int, where: PlayerWhereInput): [Player!]!
  playersConnection(after: String, before: String, first: Int, last: Int, orderBy: PlayerOrderByInput, skip: Int, where: PlayerWhereInput): PlayerConnection!
  tech(where: TechWhereUniqueInput!): Tech
  teches(after: String, before: String, first: Int, last: Int, orderBy: TechOrderByInput, skip: Int, where: TechWhereInput): [Tech!]!
  techesConnection(after: String, before: String, first: Int, last: Int, orderBy: TechOrderByInput, skip: Int, where: TechWhereInput): TechConnection!
  tile(where: TileWhereUniqueInput!): Tile
  tiles(after: String, before: String, first: Int, last: Int, orderBy: TileOrderByInput, skip: Int, where: TileWhereInput): [Tile!]!
  tilesConnection(after: String, before: String, first: Int, last: Int, orderBy: TileOrderByInput, skip: Int, where: TileWhereInput): TileConnection!
  unit(where: UnitWhereUniqueInput!): Unit
  units(after: String, before: String, first: Int, last: Int, orderBy: UnitOrderByInput, skip: Int, where: UnitWhereInput): [Unit!]!
  unitsConnection(after: String, before: String, first: Int, last: Int, orderBy: UnitOrderByInput, skip: Int, where: UnitWhereInput): UnitConnection!
}

type StringTS {
  time: DateTime!
  value: String!
}

input StringTSCreateInput {
  value: String!
}

input StringTSCreateManyInput {
  create: [StringTSCreateInput!]
}

input StringTSRestrictedWhereInput {
  AND: [StringTSRestrictedWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: String
  value_contains: String
  value_ends_with: String
  value_gt: String
  value_gte: String
  value_in: [String!]
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_ends_with: String
  value_not_in: [String!]
  value_not_starts_with: String
  value_starts_with: String
}

input StringTSScalarWhereInput {
  AND: [StringTSScalarWhereInput!]
  NOT: [StringTSScalarWhereInput!]
  OR: [StringTSScalarWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: String
  value_contains: String
  value_ends_with: String
  value_gt: String
  value_gte: String
  value_in: [String!]
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_ends_with: String
  value_not_in: [String!]
  value_not_starts_with: String
  value_starts_with: String
}

input StringTSUpdateManyDataInput {
  value: String
}

input StringTSUpdateManyInput {
  create: [StringTSCreateInput!]
  deleteMany: [StringTSScalarWhereInput!]
  updateMany: [StringTSUpdateManyWithWhereNestedInput!]
}

input StringTSUpdateManyWithWhereNestedInput {
  data: StringTSUpdateManyDataInput!
  where: StringTSScalarWhereInput!
}

input StringTSWhereInput {
  AND: [StringTSWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: String
  value_contains: String
  value_ends_with: String
  value_gt: String
  value_gte: String
  value_in: [String!]
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_ends_with: String
  value_not_in: [String!]
  value_not_starts_with: String
  value_starts_with: String
}

type Tech {
  boosted: [BooleanTS!]
  cost: Int!
  id: ID!
  progress: [FloatTS!]
  type: Int!
}

type TechConnection {
  aggregate: AggregateTech!
  edges: [TechEdge!]!
  pageInfo: PageInfo!
}

input TechCreateInput {
  boosted: BooleanTSCreateManyInput
  cost: Int!
  id: ID
  progress: FloatTSCreateManyInput
  type: Int!
}

input TechCreateManyInput {
  connect: [TechWhereUniqueInput!]
  create: [TechCreateInput!]
}

type TechEdge {
  cursor: String!
  node: Tech!
}

enum TechOrderByInput {
  cost_ASC
  cost_DESC
  id_ASC
  id_DESC
  type_ASC
  type_DESC
}

input TechScalarWhereInput {
  AND: [TechScalarWhereInput!]
  cost: Int
  cost_gt: Int
  cost_gte: Int
  cost_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_not: Int
  cost_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [TechScalarWhereInput!]
  OR: [TechScalarWhereInput!]
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
}

input TechUpdateDataInput {
  boosted: BooleanTSUpdateManyInput
  cost: Int
  progress: FloatTSUpdateManyInput
  type: Int
}

input TechUpdateInput {
  boosted: BooleanTSUpdateManyInput
  cost: Int
  progress: FloatTSUpdateManyInput
  type: Int
}

input TechUpdateManyDataInput {
  cost: Int
  type: Int
}

input TechUpdateManyInput {
  connect: [TechWhereUniqueInput!]
  create: [TechCreateInput!]
  delete: [TechWhereUniqueInput!]
  deleteMany: [TechScalarWhereInput!]
  disconnect: [TechWhereUniqueInput!]
  set: [TechWhereUniqueInput!]
  update: [TechUpdateWithWhereUniqueNestedInput!]
  updateMany: [TechUpdateManyWithWhereNestedInput!]
  upsert: [TechUpsertWithWhereUniqueNestedInput!]
}

input TechUpdateManyMutationInput {
  cost: Int
  type: Int
}

input TechUpdateManyWithWhereNestedInput {
  data: TechUpdateManyDataInput!
  where: TechScalarWhereInput!
}

input TechUpdateWithWhereUniqueNestedInput {
  data: TechUpdateDataInput!
  where: TechWhereUniqueInput!
}

input TechUpsertWithWhereUniqueNestedInput {
  create: TechCreateInput!
  update: TechUpdateDataInput!
  where: TechWhereUniqueInput!
}

input TechWhereInput {
  AND: [TechWhereInput!]
  boosted_every: BooleanTSRestrictedWhereInput
  boosted_none: BooleanTSRestrictedWhereInput
  boosted_some: BooleanTSWhereInput
  cost: Int
  cost_gt: Int
  cost_gte: Int
  cost_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_not: Int
  cost_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  progress_every: FloatTSRestrictedWhereInput
  progress_none: FloatTSRestrictedWhereInput
  progress_some: FloatTSWhereInput
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
}

input TechWhereUniqueInput {
  id: ID
}

type Tile {
  feature: [IntTS!]
  id: ID!
  location: [Int!]!
  terrain: [IntTS!]
}

type TileConnection {
  aggregate: AggregateTile!
  edges: [TileEdge!]!
  pageInfo: PageInfo!
}

input TileCreateInput {
  feature: IntTSCreateManyInput
  id: ID
  location: TileCreatelocationInput
  terrain: IntTSCreateManyInput
}

input TileCreatelocationInput {
  set: [Int!]
}

input TileCreateManyInput {
  connect: [TileWhereUniqueInput!]
  create: [TileCreateInput!]
}

input TileCreateOneInput {
  connect: TileWhereUniqueInput
  create: TileCreateInput
}

type TileEdge {
  cursor: String!
  node: Tile!
}

enum TileOrderByInput {
  id_ASC
  id_DESC
}

input TileScalarWhereInput {
  AND: [TileScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [TileScalarWhereInput!]
  OR: [TileScalarWhereInput!]
}

type TileTS {
  time: DateTime!
  value: Tile!
}

input TileTSCreateInput {
  value: TileCreateOneInput!
}

input TileTSCreateManyInput {
  create: [TileTSCreateInput!]
}

input TileTSRestrictedWhereInput {
  AND: [TileTSRestrictedWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
}

input TileTSScalarWhereInput {
  AND: [TileTSScalarWhereInput!]
  NOT: [TileTSScalarWhereInput!]
  OR: [TileTSScalarWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
}

input TileTSUpdateManyInput {
  create: [TileTSCreateInput!]
  deleteMany: [TileTSScalarWhereInput!]
}

input TileTSWhereInput {
  AND: [TileTSWhereInput!]
  time: DateTime
  time_gt: DateTime
  time_gte: DateTime
  time_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_not: DateTime
  time_not_in: [DateTime!]
  value: TileWhereInput
}

input TileUpdateDataInput {
  feature: IntTSUpdateManyInput
  location: TileUpdatelocationInput
  terrain: IntTSUpdateManyInput
}

input TileUpdateInput {
  feature: IntTSUpdateManyInput
  location: TileUpdatelocationInput
  terrain: IntTSUpdateManyInput
}

input TileUpdatelocationInput {
  set: [Int!]
}

input TileUpdateManyDataInput {
  location: TileUpdatelocationInput
}

input TileUpdateManyInput {
  connect: [TileWhereUniqueInput!]
  create: [TileCreateInput!]
  delete: [TileWhereUniqueInput!]
  deleteMany: [TileScalarWhereInput!]
  disconnect: [TileWhereUniqueInput!]
  set: [TileWhereUniqueInput!]
  update: [TileUpdateWithWhereUniqueNestedInput!]
  updateMany: [TileUpdateManyWithWhereNestedInput!]
  upsert: [TileUpsertWithWhereUniqueNestedInput!]
}

input TileUpdateManyMutationInput {
  location: TileUpdatelocationInput
}

input TileUpdateManyWithWhereNestedInput {
  data: TileUpdateManyDataInput!
  where: TileScalarWhereInput!
}

input TileUpdateWithWhereUniqueNestedInput {
  data: TileUpdateDataInput!
  where: TileWhereUniqueInput!
}

input TileUpsertWithWhereUniqueNestedInput {
  create: TileCreateInput!
  update: TileUpdateDataInput!
  where: TileWhereUniqueInput!
}

input TileWhereInput {
  AND: [TileWhereInput!]
  feature_every: IntTSRestrictedWhereInput
  feature_none: IntTSRestrictedWhereInput
  feature_some: IntTSWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  terrain_every: IntTSRestrictedWhereInput
  terrain_none: IntTSRestrictedWhereInput
  terrain_some: IntTSWhereInput
}

input TileWhereUniqueInput {
  id: ID
}

type Unit {
  baseMoves: Int
  bombard: Int
  combat: Int
  cost: Int!
  id: ID!
  location: [TileTS!]
  range: Int
  rangedCombar: Int
  type: Int!
}

type UnitConnection {
  aggregate: AggregateUnit!
  edges: [UnitEdge!]!
  pageInfo: PageInfo!
}

input UnitCreateInput {
  baseMoves: Int
  bombard: Int
  combat: Int
  cost: Int!
  id: ID
  location: TileTSCreateManyInput
  range: Int
  rangedCombar: Int
  type: Int!
}

input UnitCreateManyInput {
  connect: [UnitWhereUniqueInput!]
  create: [UnitCreateInput!]
}

type UnitEdge {
  cursor: String!
  node: Unit!
}

enum UnitOrderByInput {
  baseMoves_ASC
  baseMoves_DESC
  bombard_ASC
  bombard_DESC
  combat_ASC
  combat_DESC
  cost_ASC
  cost_DESC
  id_ASC
  id_DESC
  range_ASC
  range_DESC
  rangedCombar_ASC
  rangedCombar_DESC
  type_ASC
  type_DESC
}

input UnitScalarWhereInput {
  AND: [UnitScalarWhereInput!]
  baseMoves: Int
  baseMoves_gt: Int
  baseMoves_gte: Int
  baseMoves_in: [Int!]
  baseMoves_lt: Int
  baseMoves_lte: Int
  baseMoves_not: Int
  baseMoves_not_in: [Int!]
  bombard: Int
  bombard_gt: Int
  bombard_gte: Int
  bombard_in: [Int!]
  bombard_lt: Int
  bombard_lte: Int
  bombard_not: Int
  bombard_not_in: [Int!]
  combat: Int
  combat_gt: Int
  combat_gte: Int
  combat_in: [Int!]
  combat_lt: Int
  combat_lte: Int
  combat_not: Int
  combat_not_in: [Int!]
  cost: Int
  cost_gt: Int
  cost_gte: Int
  cost_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_not: Int
  cost_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [UnitScalarWhereInput!]
  OR: [UnitScalarWhereInput!]
  range: Int
  range_gt: Int
  range_gte: Int
  range_in: [Int!]
  range_lt: Int
  range_lte: Int
  range_not: Int
  range_not_in: [Int!]
  rangedCombar: Int
  rangedCombar_gt: Int
  rangedCombar_gte: Int
  rangedCombar_in: [Int!]
  rangedCombar_lt: Int
  rangedCombar_lte: Int
  rangedCombar_not: Int
  rangedCombar_not_in: [Int!]
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
}

input UnitUpdateDataInput {
  baseMoves: Int
  bombard: Int
  combat: Int
  cost: Int
  location: TileTSUpdateManyInput
  range: Int
  rangedCombar: Int
  type: Int
}

input UnitUpdateInput {
  baseMoves: Int
  bombard: Int
  combat: Int
  cost: Int
  location: TileTSUpdateManyInput
  range: Int
  rangedCombar: Int
  type: Int
}

input UnitUpdateManyDataInput {
  baseMoves: Int
  bombard: Int
  combat: Int
  cost: Int
  range: Int
  rangedCombar: Int
  type: Int
}

input UnitUpdateManyInput {
  connect: [UnitWhereUniqueInput!]
  create: [UnitCreateInput!]
  delete: [UnitWhereUniqueInput!]
  deleteMany: [UnitScalarWhereInput!]
  disconnect: [UnitWhereUniqueInput!]
  set: [UnitWhereUniqueInput!]
  update: [UnitUpdateWithWhereUniqueNestedInput!]
  updateMany: [UnitUpdateManyWithWhereNestedInput!]
  upsert: [UnitUpsertWithWhereUniqueNestedInput!]
}

input UnitUpdateManyMutationInput {
  baseMoves: Int
  bombard: Int
  combat: Int
  cost: Int
  range: Int
  rangedCombar: Int
  type: Int
}

input UnitUpdateManyWithWhereNestedInput {
  data: UnitUpdateManyDataInput!
  where: UnitScalarWhereInput!
}

input UnitUpdateWithWhereUniqueNestedInput {
  data: UnitUpdateDataInput!
  where: UnitWhereUniqueInput!
}

input UnitUpsertWithWhereUniqueNestedInput {
  create: UnitCreateInput!
  update: UnitUpdateDataInput!
  where: UnitWhereUniqueInput!
}

input UnitWhereInput {
  AND: [UnitWhereInput!]
  baseMoves: Int
  baseMoves_gt: Int
  baseMoves_gte: Int
  baseMoves_in: [Int!]
  baseMoves_lt: Int
  baseMoves_lte: Int
  baseMoves_not: Int
  baseMoves_not_in: [Int!]
  bombard: Int
  bombard_gt: Int
  bombard_gte: Int
  bombard_in: [Int!]
  bombard_lt: Int
  bombard_lte: Int
  bombard_not: Int
  bombard_not_in: [Int!]
  combat: Int
  combat_gt: Int
  combat_gte: Int
  combat_in: [Int!]
  combat_lt: Int
  combat_lte: Int
  combat_not: Int
  combat_not_in: [Int!]
  cost: Int
  cost_gt: Int
  cost_gte: Int
  cost_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_not: Int
  cost_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  location_every: TileTSRestrictedWhereInput
  location_none: TileTSRestrictedWhereInput
  location_some: TileTSWhereInput
  range: Int
  range_gt: Int
  range_gte: Int
  range_in: [Int!]
  range_lt: Int
  range_lte: Int
  range_not: Int
  range_not_in: [Int!]
  rangedCombar: Int
  rangedCombar_gt: Int
  rangedCombar_gte: Int
  rangedCombar_in: [Int!]
  rangedCombar_lt: Int
  rangedCombar_lte: Int
  rangedCombar_not: Int
  rangedCombar_not_in: [Int!]
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
}

input UnitWhereUniqueInput {
  id: ID
}
