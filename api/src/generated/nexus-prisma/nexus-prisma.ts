/**
 * This file was automatically generated by nexus-prisma@0.3.7
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
  interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
  objectTypes: {
    fields: {
      Query: QueryObject
      Game: GameObject
      Leader: LeaderObject
      Player: PlayerObject
      StringTS: StringTSObject
      BooleanTS: BooleanTSObject
      City: CityObject
      IntTS: IntTSObject
      TileTS: TileTSObject
      Tile: TileObject
      Tech: TechObject
      FloatTS: FloatTSObject
      Civic: CivicObject
      Unit: UnitObject
      Map: MapObject
      GameConnection: GameConnectionObject
      PageInfo: PageInfoObject
      GameEdge: GameEdgeObject
      AggregateGame: AggregateGameObject
      LeaderConnection: LeaderConnectionObject
      LeaderEdge: LeaderEdgeObject
      AggregateLeader: AggregateLeaderObject
      PlayerConnection: PlayerConnectionObject
      PlayerEdge: PlayerEdgeObject
      AggregatePlayer: AggregatePlayerObject
      CityConnection: CityConnectionObject
      CityEdge: CityEdgeObject
      AggregateCity: AggregateCityObject
      UnitConnection: UnitConnectionObject
      UnitEdge: UnitEdgeObject
      AggregateUnit: AggregateUnitObject
      TechConnection: TechConnectionObject
      TechEdge: TechEdgeObject
      AggregateTech: AggregateTechObject
      CivicConnection: CivicConnectionObject
      CivicEdge: CivicEdgeObject
      AggregateCivic: AggregateCivicObject
      MapConnection: MapConnectionObject
      MapEdge: MapEdgeObject
      AggregateMap: AggregateMapObject
      TileConnection: TileConnectionObject
      TileEdge: TileEdgeObject
      AggregateTile: AggregateTileObject
      Mutation: MutationObject
      BatchPayload: BatchPayloadObject
      Subscription: SubscriptionObject
      GameSubscriptionPayload: GameSubscriptionPayloadObject
      GamePreviousValues: GamePreviousValuesObject
      LeaderSubscriptionPayload: LeaderSubscriptionPayloadObject
      LeaderPreviousValues: LeaderPreviousValuesObject
      PlayerSubscriptionPayload: PlayerSubscriptionPayloadObject
      PlayerPreviousValues: PlayerPreviousValuesObject
      CitySubscriptionPayload: CitySubscriptionPayloadObject
      CityPreviousValues: CityPreviousValuesObject
      UnitSubscriptionPayload: UnitSubscriptionPayloadObject
      UnitPreviousValues: UnitPreviousValuesObject
      TechSubscriptionPayload: TechSubscriptionPayloadObject
      TechPreviousValues: TechPreviousValuesObject
      CivicSubscriptionPayload: CivicSubscriptionPayloadObject
      CivicPreviousValues: CivicPreviousValuesObject
      MapSubscriptionPayload: MapSubscriptionPayloadObject
      MapPreviousValues: MapPreviousValuesObject
      TileSubscriptionPayload: TileSubscriptionPayloadObject
      TilePreviousValues: TilePreviousValuesObject
    }
    fieldsDetails: {
      Query: QueryFieldDetails
      Game: GameFieldDetails
      Leader: LeaderFieldDetails
      Player: PlayerFieldDetails
      StringTS: StringTSFieldDetails
      BooleanTS: BooleanTSFieldDetails
      City: CityFieldDetails
      IntTS: IntTSFieldDetails
      TileTS: TileTSFieldDetails
      Tile: TileFieldDetails
      Tech: TechFieldDetails
      FloatTS: FloatTSFieldDetails
      Civic: CivicFieldDetails
      Unit: UnitFieldDetails
      Map: MapFieldDetails
      GameConnection: GameConnectionFieldDetails
      PageInfo: PageInfoFieldDetails
      GameEdge: GameEdgeFieldDetails
      AggregateGame: AggregateGameFieldDetails
      LeaderConnection: LeaderConnectionFieldDetails
      LeaderEdge: LeaderEdgeFieldDetails
      AggregateLeader: AggregateLeaderFieldDetails
      PlayerConnection: PlayerConnectionFieldDetails
      PlayerEdge: PlayerEdgeFieldDetails
      AggregatePlayer: AggregatePlayerFieldDetails
      CityConnection: CityConnectionFieldDetails
      CityEdge: CityEdgeFieldDetails
      AggregateCity: AggregateCityFieldDetails
      UnitConnection: UnitConnectionFieldDetails
      UnitEdge: UnitEdgeFieldDetails
      AggregateUnit: AggregateUnitFieldDetails
      TechConnection: TechConnectionFieldDetails
      TechEdge: TechEdgeFieldDetails
      AggregateTech: AggregateTechFieldDetails
      CivicConnection: CivicConnectionFieldDetails
      CivicEdge: CivicEdgeFieldDetails
      AggregateCivic: AggregateCivicFieldDetails
      MapConnection: MapConnectionFieldDetails
      MapEdge: MapEdgeFieldDetails
      AggregateMap: AggregateMapFieldDetails
      TileConnection: TileConnectionFieldDetails
      TileEdge: TileEdgeFieldDetails
      AggregateTile: AggregateTileFieldDetails
      Mutation: MutationFieldDetails
      BatchPayload: BatchPayloadFieldDetails
      Subscription: SubscriptionFieldDetails
      GameSubscriptionPayload: GameSubscriptionPayloadFieldDetails
      GamePreviousValues: GamePreviousValuesFieldDetails
      LeaderSubscriptionPayload: LeaderSubscriptionPayloadFieldDetails
      LeaderPreviousValues: LeaderPreviousValuesFieldDetails
      PlayerSubscriptionPayload: PlayerSubscriptionPayloadFieldDetails
      PlayerPreviousValues: PlayerPreviousValuesFieldDetails
      CitySubscriptionPayload: CitySubscriptionPayloadFieldDetails
      CityPreviousValues: CityPreviousValuesFieldDetails
      UnitSubscriptionPayload: UnitSubscriptionPayloadFieldDetails
      UnitPreviousValues: UnitPreviousValuesFieldDetails
      TechSubscriptionPayload: TechSubscriptionPayloadFieldDetails
      TechPreviousValues: TechPreviousValuesFieldDetails
      CivicSubscriptionPayload: CivicSubscriptionPayloadFieldDetails
      CivicPreviousValues: CivicPreviousValuesFieldDetails
      MapSubscriptionPayload: MapSubscriptionPayloadFieldDetails
      MapPreviousValues: MapPreviousValuesFieldDetails
      TileSubscriptionPayload: TileSubscriptionPayloadFieldDetails
      TilePreviousValues: TilePreviousValuesFieldDetails
    }
  }
  inputTypes: {
    fields: {
      GameWhereUniqueInput: GameWhereUniqueInputInputObject
      LeaderWhereInput: LeaderWhereInputInputObject
      PlayerWhereInput: PlayerWhereInputInputObject
      StringTSWhereInput: StringTSWhereInputInputObject
      StringTSRestrictedWhereInput: StringTSRestrictedWhereInputInputObject
      BooleanTSWhereInput: BooleanTSWhereInputInputObject
      BooleanTSRestrictedWhereInput: BooleanTSRestrictedWhereInputInputObject
      CityWhereInput: CityWhereInputInputObject
      IntTSWhereInput: IntTSWhereInputInputObject
      IntTSRestrictedWhereInput: IntTSRestrictedWhereInputInputObject
      TileTSWhereInput: TileTSWhereInputInputObject
      TileWhereInput: TileWhereInputInputObject
      TileTSRestrictedWhereInput: TileTSRestrictedWhereInputInputObject
      TechWhereInput: TechWhereInputInputObject
      FloatTSWhereInput: FloatTSWhereInputInputObject
      FloatTSRestrictedWhereInput: FloatTSRestrictedWhereInputInputObject
      CivicWhereInput: CivicWhereInputInputObject
      UnitWhereInput: UnitWhereInputInputObject
      GameWhereInput: GameWhereInputInputObject
      MapWhereInput: MapWhereInputInputObject
      LeaderWhereUniqueInput: LeaderWhereUniqueInputInputObject
      PlayerWhereUniqueInput: PlayerWhereUniqueInputInputObject
      CityWhereUniqueInput: CityWhereUniqueInputInputObject
      UnitWhereUniqueInput: UnitWhereUniqueInputInputObject
      TechWhereUniqueInput: TechWhereUniqueInputInputObject
      CivicWhereUniqueInput: CivicWhereUniqueInputInputObject
      MapWhereUniqueInput: MapWhereUniqueInputInputObject
      TileWhereUniqueInput: TileWhereUniqueInputInputObject
      GameCreateInput: GameCreateInputInputObject
      LeaderCreateManyInput: LeaderCreateManyInputInputObject
      LeaderCreateInput: LeaderCreateInputInputObject
      PlayerCreateOneInput: PlayerCreateOneInputInputObject
      PlayerCreateInput: PlayerCreateInputInputObject
      StringTSCreateManyInput: StringTSCreateManyInputInputObject
      StringTSCreateInput: StringTSCreateInputInputObject
      BooleanTSCreateManyInput: BooleanTSCreateManyInputInputObject
      BooleanTSCreateInput: BooleanTSCreateInputInputObject
      CityCreateManyInput: CityCreateManyInputInputObject
      CityCreateInput: CityCreateInputInputObject
      IntTSCreateManyInput: IntTSCreateManyInputInputObject
      IntTSCreateInput: IntTSCreateInputInputObject
      TileTSCreateManyInput: TileTSCreateManyInputInputObject
      TileTSCreateInput: TileTSCreateInputInputObject
      TileCreateOneInput: TileCreateOneInputInputObject
      TileCreateInput: TileCreateInputInputObject
      TileCreatelocationInput: TileCreatelocationInputInputObject
      TechCreateManyInput: TechCreateManyInputInputObject
      TechCreateInput: TechCreateInputInputObject
      FloatTSCreateManyInput: FloatTSCreateManyInputInputObject
      FloatTSCreateInput: FloatTSCreateInputInputObject
      CivicCreateManyInput: CivicCreateManyInputInputObject
      CivicCreateInput: CivicCreateInputInputObject
      UnitCreateManyInput: UnitCreateManyInputInputObject
      UnitCreateInput: UnitCreateInputInputObject
      MapCreateOneInput: MapCreateOneInputInputObject
      MapCreateInput: MapCreateInputInputObject
      TileCreateManyInput: TileCreateManyInputInputObject
      GameUpdateInput: GameUpdateInputInputObject
      LeaderUpdateManyInput: LeaderUpdateManyInputInputObject
      LeaderUpdateWithWhereUniqueNestedInput: LeaderUpdateWithWhereUniqueNestedInputInputObject
      LeaderUpdateDataInput: LeaderUpdateDataInputInputObject
      PlayerUpdateOneRequiredInput: PlayerUpdateOneRequiredInputInputObject
      PlayerUpdateDataInput: PlayerUpdateDataInputInputObject
      StringTSUpdateManyInput: StringTSUpdateManyInputInputObject
      StringTSScalarWhereInput: StringTSScalarWhereInputInputObject
      StringTSUpdateManyWithWhereNestedInput: StringTSUpdateManyWithWhereNestedInputInputObject
      StringTSUpdateManyDataInput: StringTSUpdateManyDataInputInputObject
      BooleanTSUpdateManyInput: BooleanTSUpdateManyInputInputObject
      BooleanTSScalarWhereInput: BooleanTSScalarWhereInputInputObject
      BooleanTSUpdateManyWithWhereNestedInput: BooleanTSUpdateManyWithWhereNestedInputInputObject
      BooleanTSUpdateManyDataInput: BooleanTSUpdateManyDataInputInputObject
      PlayerUpsertNestedInput: PlayerUpsertNestedInputInputObject
      CityUpdateManyInput: CityUpdateManyInputInputObject
      CityUpdateWithWhereUniqueNestedInput: CityUpdateWithWhereUniqueNestedInputInputObject
      CityUpdateDataInput: CityUpdateDataInputInputObject
      IntTSUpdateManyInput: IntTSUpdateManyInputInputObject
      IntTSScalarWhereInput: IntTSScalarWhereInputInputObject
      IntTSUpdateManyWithWhereNestedInput: IntTSUpdateManyWithWhereNestedInputInputObject
      IntTSUpdateManyDataInput: IntTSUpdateManyDataInputInputObject
      TileTSUpdateManyInput: TileTSUpdateManyInputInputObject
      TileTSScalarWhereInput: TileTSScalarWhereInputInputObject
      CityUpsertWithWhereUniqueNestedInput: CityUpsertWithWhereUniqueNestedInputInputObject
      CityScalarWhereInput: CityScalarWhereInputInputObject
      TechUpdateManyInput: TechUpdateManyInputInputObject
      TechUpdateWithWhereUniqueNestedInput: TechUpdateWithWhereUniqueNestedInputInputObject
      TechUpdateDataInput: TechUpdateDataInputInputObject
      FloatTSUpdateManyInput: FloatTSUpdateManyInputInputObject
      FloatTSScalarWhereInput: FloatTSScalarWhereInputInputObject
      FloatTSUpdateManyWithWhereNestedInput: FloatTSUpdateManyWithWhereNestedInputInputObject
      FloatTSUpdateManyDataInput: FloatTSUpdateManyDataInputInputObject
      TechUpsertWithWhereUniqueNestedInput: TechUpsertWithWhereUniqueNestedInputInputObject
      TechScalarWhereInput: TechScalarWhereInputInputObject
      TechUpdateManyWithWhereNestedInput: TechUpdateManyWithWhereNestedInputInputObject
      TechUpdateManyDataInput: TechUpdateManyDataInputInputObject
      CivicUpdateManyInput: CivicUpdateManyInputInputObject
      CivicUpdateWithWhereUniqueNestedInput: CivicUpdateWithWhereUniqueNestedInputInputObject
      CivicUpdateDataInput: CivicUpdateDataInputInputObject
      CivicUpsertWithWhereUniqueNestedInput: CivicUpsertWithWhereUniqueNestedInputInputObject
      CivicScalarWhereInput: CivicScalarWhereInputInputObject
      CivicUpdateManyWithWhereNestedInput: CivicUpdateManyWithWhereNestedInputInputObject
      CivicUpdateManyDataInput: CivicUpdateManyDataInputInputObject
      UnitUpdateManyInput: UnitUpdateManyInputInputObject
      UnitUpdateWithWhereUniqueNestedInput: UnitUpdateWithWhereUniqueNestedInputInputObject
      UnitUpdateDataInput: UnitUpdateDataInputInputObject
      UnitUpsertWithWhereUniqueNestedInput: UnitUpsertWithWhereUniqueNestedInputInputObject
      UnitScalarWhereInput: UnitScalarWhereInputInputObject
      UnitUpdateManyWithWhereNestedInput: UnitUpdateManyWithWhereNestedInputInputObject
      UnitUpdateManyDataInput: UnitUpdateManyDataInputInputObject
      LeaderUpsertWithWhereUniqueNestedInput: LeaderUpsertWithWhereUniqueNestedInputInputObject
      LeaderScalarWhereInput: LeaderScalarWhereInputInputObject
      LeaderUpdateManyWithWhereNestedInput: LeaderUpdateManyWithWhereNestedInputInputObject
      LeaderUpdateManyDataInput: LeaderUpdateManyDataInputInputObject
      MapUpdateOneRequiredInput: MapUpdateOneRequiredInputInputObject
      MapUpdateDataInput: MapUpdateDataInputInputObject
      TileUpdateManyInput: TileUpdateManyInputInputObject
      TileUpdateWithWhereUniqueNestedInput: TileUpdateWithWhereUniqueNestedInputInputObject
      TileUpdateDataInput: TileUpdateDataInputInputObject
      TileUpdatelocationInput: TileUpdatelocationInputInputObject
      TileUpsertWithWhereUniqueNestedInput: TileUpsertWithWhereUniqueNestedInputInputObject
      TileScalarWhereInput: TileScalarWhereInputInputObject
      TileUpdateManyWithWhereNestedInput: TileUpdateManyWithWhereNestedInputInputObject
      TileUpdateManyDataInput: TileUpdateManyDataInputInputObject
      MapUpsertNestedInput: MapUpsertNestedInputInputObject
      GameUpdateManyMutationInput: GameUpdateManyMutationInputInputObject
      LeaderUpdateInput: LeaderUpdateInputInputObject
      LeaderUpdateManyMutationInput: LeaderUpdateManyMutationInputInputObject
      PlayerUpdateInput: PlayerUpdateInputInputObject
      CityUpdateInput: CityUpdateInputInputObject
      UnitUpdateInput: UnitUpdateInputInputObject
      UnitUpdateManyMutationInput: UnitUpdateManyMutationInputInputObject
      TechUpdateInput: TechUpdateInputInputObject
      TechUpdateManyMutationInput: TechUpdateManyMutationInputInputObject
      CivicUpdateInput: CivicUpdateInputInputObject
      CivicUpdateManyMutationInput: CivicUpdateManyMutationInputInputObject
      MapUpdateInput: MapUpdateInputInputObject
      MapUpdateManyMutationInput: MapUpdateManyMutationInputInputObject
      TileUpdateInput: TileUpdateInputInputObject
      TileUpdateManyMutationInput: TileUpdateManyMutationInputInputObject
      GameSubscriptionWhereInput: GameSubscriptionWhereInputInputObject
      LeaderSubscriptionWhereInput: LeaderSubscriptionWhereInputInputObject
      PlayerSubscriptionWhereInput: PlayerSubscriptionWhereInputInputObject
      CitySubscriptionWhereInput: CitySubscriptionWhereInputInputObject
      UnitSubscriptionWhereInput: UnitSubscriptionWhereInputInputObject
      TechSubscriptionWhereInput: TechSubscriptionWhereInputInputObject
      CivicSubscriptionWhereInput: CivicSubscriptionWhereInputInputObject
      MapSubscriptionWhereInput: MapSubscriptionWhereInputInputObject
      TileSubscriptionWhereInput: TileSubscriptionWhereInputInputObject
    }
  }
  enumTypes: {
    LeaderOrderByInput: LeaderOrderByInputValues,
    CityOrderByInput: CityOrderByInputValues,
    TechOrderByInput: TechOrderByInputValues,
    CivicOrderByInput: CivicOrderByInputValues,
    UnitOrderByInput: UnitOrderByInputValues,
    TileOrderByInput: TileOrderByInputValues,
    GameOrderByInput: GameOrderByInputValues,
    PlayerOrderByInput: PlayerOrderByInputValues,
    MapOrderByInput: MapOrderByInputValues,
    MutationType: MutationTypeValues,
  }
}

// Types for Query

type QueryObject =
  | QueryFields
  | { name: 'game', args?: QueryGameArgs[] | false, alias?: string  } 
  | { name: 'games', args?: QueryGamesArgs[] | false, alias?: string  } 
  | { name: 'gamesConnection', args?: QueryGamesConnectionArgs[] | false, alias?: string  } 
  | { name: 'leader', args?: QueryLeaderArgs[] | false, alias?: string  } 
  | { name: 'leaders', args?: QueryLeadersArgs[] | false, alias?: string  } 
  | { name: 'leadersConnection', args?: QueryLeadersConnectionArgs[] | false, alias?: string  } 
  | { name: 'player', args?: QueryPlayerArgs[] | false, alias?: string  } 
  | { name: 'players', args?: QueryPlayersArgs[] | false, alias?: string  } 
  | { name: 'playersConnection', args?: QueryPlayersConnectionArgs[] | false, alias?: string  } 
  | { name: 'city', args?: QueryCityArgs[] | false, alias?: string  } 
  | { name: 'cities', args?: QueryCitiesArgs[] | false, alias?: string  } 
  | { name: 'citiesConnection', args?: QueryCitiesConnectionArgs[] | false, alias?: string  } 
  | { name: 'unit', args?: QueryUnitArgs[] | false, alias?: string  } 
  | { name: 'units', args?: QueryUnitsArgs[] | false, alias?: string  } 
  | { name: 'unitsConnection', args?: QueryUnitsConnectionArgs[] | false, alias?: string  } 
  | { name: 'tech', args?: QueryTechArgs[] | false, alias?: string  } 
  | { name: 'teches', args?: QueryTechesArgs[] | false, alias?: string  } 
  | { name: 'techesConnection', args?: QueryTechesConnectionArgs[] | false, alias?: string  } 
  | { name: 'civic', args?: QueryCivicArgs[] | false, alias?: string  } 
  | { name: 'civics', args?: QueryCivicsArgs[] | false, alias?: string  } 
  | { name: 'civicsConnection', args?: QueryCivicsConnectionArgs[] | false, alias?: string  } 
  | { name: 'map', args?: QueryMapArgs[] | false, alias?: string  } 
  | { name: 'maps', args?: QueryMapsArgs[] | false, alias?: string  } 
  | { name: 'mapsConnection', args?: QueryMapsConnectionArgs[] | false, alias?: string  } 
  | { name: 'tile', args?: QueryTileArgs[] | false, alias?: string  } 
  | { name: 'tiles', args?: QueryTilesArgs[] | false, alias?: string  } 
  | { name: 'tilesConnection', args?: QueryTilesConnectionArgs[] | false, alias?: string  } 

type QueryFields =
  | 'game'
  | 'games'
  | 'gamesConnection'
  | 'leader'
  | 'leaders'
  | 'leadersConnection'
  | 'player'
  | 'players'
  | 'playersConnection'
  | 'city'
  | 'cities'
  | 'citiesConnection'
  | 'unit'
  | 'units'
  | 'unitsConnection'
  | 'tech'
  | 'teches'
  | 'techesConnection'
  | 'civic'
  | 'civics'
  | 'civicsConnection'
  | 'map'
  | 'maps'
  | 'mapsConnection'
  | 'tile'
  | 'tiles'
  | 'tilesConnection'


type QueryGameArgs =
  | 'where'
type QueryGamesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryGamesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryLeaderArgs =
  | 'where'
type QueryLeadersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryLeadersConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryPlayerArgs =
  | 'where'
type QueryPlayersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryPlayersConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCityArgs =
  | 'where'
type QueryCitiesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCitiesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryUnitArgs =
  | 'where'
type QueryUnitsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryUnitsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTechArgs =
  | 'where'
type QueryTechesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTechesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCivicArgs =
  | 'where'
type QueryCivicsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCivicsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryMapArgs =
  | 'where'
type QueryMapsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryMapsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTileArgs =
  | 'where'
type QueryTilesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTilesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface QueryFieldDetails {
  game: {
    type: 'Game'
    args: Record<QueryGameArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: GameWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Game | null> | prisma.Game | null
  }
  games: {
    type: 'Game'
    args: Record<QueryGamesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: GameWhereInput | null, orderBy?: prisma.GameOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Game[]> | prisma.Game[]
  }
  gamesConnection: {
    type: 'GameConnection'
    args: Record<QueryGamesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: GameWhereInput | null, orderBy?: prisma.GameOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.GameConnection> | prisma.GameConnection
  }
  leader: {
    type: 'Leader'
    args: Record<QueryLeaderArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: LeaderWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader | null> | prisma.Leader | null
  }
  leaders: {
    type: 'Leader'
    args: Record<QueryLeadersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: LeaderWhereInput | null, orderBy?: prisma.LeaderOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader[]> | prisma.Leader[]
  }
  leadersConnection: {
    type: 'LeaderConnection'
    args: Record<QueryLeadersConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: LeaderWhereInput | null, orderBy?: prisma.LeaderOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.LeaderConnection> | prisma.LeaderConnection
  }
  player: {
    type: 'Player'
    args: Record<QueryPlayerArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: PlayerWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player | null> | prisma.Player | null
  }
  players: {
    type: 'Player'
    args: Record<QueryPlayersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: PlayerWhereInput | null, orderBy?: prisma.PlayerOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player[]> | prisma.Player[]
  }
  playersConnection: {
    type: 'PlayerConnection'
    args: Record<QueryPlayersConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: PlayerWhereInput | null, orderBy?: prisma.PlayerOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PlayerConnection> | prisma.PlayerConnection
  }
  city: {
    type: 'City'
    args: Record<QueryCityArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: CityWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City | null> | prisma.City | null
  }
  cities: {
    type: 'City'
    args: Record<QueryCitiesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CityWhereInput | null, orderBy?: prisma.CityOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City[]> | prisma.City[]
  }
  citiesConnection: {
    type: 'CityConnection'
    args: Record<QueryCitiesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CityWhereInput | null, orderBy?: prisma.CityOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CityConnection> | prisma.CityConnection
  }
  unit: {
    type: 'Unit'
    args: Record<QueryUnitArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: UnitWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit | null> | prisma.Unit | null
  }
  units: {
    type: 'Unit'
    args: Record<QueryUnitsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UnitWhereInput | null, orderBy?: prisma.UnitOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit[]> | prisma.Unit[]
  }
  unitsConnection: {
    type: 'UnitConnection'
    args: Record<QueryUnitsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UnitWhereInput | null, orderBy?: prisma.UnitOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UnitConnection> | prisma.UnitConnection
  }
  tech: {
    type: 'Tech'
    args: Record<QueryTechArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: TechWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech | null> | prisma.Tech | null
  }
  teches: {
    type: 'Tech'
    args: Record<QueryTechesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TechWhereInput | null, orderBy?: prisma.TechOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech[]> | prisma.Tech[]
  }
  techesConnection: {
    type: 'TechConnection'
    args: Record<QueryTechesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TechWhereInput | null, orderBy?: prisma.TechOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TechConnection> | prisma.TechConnection
  }
  civic: {
    type: 'Civic'
    args: Record<QueryCivicArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: CivicWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic | null> | prisma.Civic | null
  }
  civics: {
    type: 'Civic'
    args: Record<QueryCivicsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CivicWhereInput | null, orderBy?: prisma.CivicOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic[]> | prisma.Civic[]
  }
  civicsConnection: {
    type: 'CivicConnection'
    args: Record<QueryCivicsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CivicWhereInput | null, orderBy?: prisma.CivicOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CivicConnection> | prisma.CivicConnection
  }
  map: {
    type: 'Map'
    args: Record<QueryMapArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: MapWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map | null> | prisma.Map | null
  }
  maps: {
    type: 'Map'
    args: Record<QueryMapsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: MapWhereInput | null, orderBy?: prisma.MapOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map[]> | prisma.Map[]
  }
  mapsConnection: {
    type: 'MapConnection'
    args: Record<QueryMapsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: MapWhereInput | null, orderBy?: prisma.MapOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MapConnection> | prisma.MapConnection
  }
  tile: {
    type: 'Tile'
    args: Record<QueryTileArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: TileWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile | null> | prisma.Tile | null
  }
  tiles: {
    type: 'Tile'
    args: Record<QueryTilesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TileWhereInput | null, orderBy?: prisma.TileOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile[]> | prisma.Tile[]
  }
  tilesConnection: {
    type: 'TileConnection'
    args: Record<QueryTilesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TileWhereInput | null, orderBy?: prisma.TileOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TileConnection> | prisma.TileConnection
  }
}
  

// Types for Game

type GameObject =
  | GameFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'leaders', args?: GameLeadersArgs[] | false, alias?: string  } 
  | { name: 'map', args?: [] | false, alias?: string  } 

type GameFields =
  | 'id'
  | 'name'
  | 'leaders'
  | 'map'


type GameLeadersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface GameFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  leaders: {
    type: 'Leader'
    args: Record<GameLeadersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Game">,
      args: { where?: LeaderWhereInput | null, orderBy?: prisma.LeaderOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader[]> | prisma.Leader[]
  }
  map: {
    type: 'Map'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Game">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map> | prisma.Map
  }
}
  

// Types for Leader

type LeaderObject =
  | LeaderFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'player', args?: [] | false, alias?: string  } 
  | { name: 'cities', args?: LeaderCitiesArgs[] | false, alias?: string  } 
  | { name: 'techs', args?: LeaderTechsArgs[] | false, alias?: string  } 
  | { name: 'civics', args?: LeaderCivicsArgs[] | false, alias?: string  } 
  | { name: 'units', args?: LeaderUnitsArgs[] | false, alias?: string  } 

type LeaderFields =
  | 'id'
  | 'name'
  | 'player'
  | 'cities'
  | 'techs'
  | 'civics'
  | 'units'


type LeaderCitiesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type LeaderTechsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type LeaderCivicsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type LeaderUnitsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface LeaderFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  player: {
    type: 'Player'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Leader">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player> | prisma.Player
  }
  cities: {
    type: 'City'
    args: Record<LeaderCitiesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Leader">,
      args: { where?: CityWhereInput | null, orderBy?: prisma.CityOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City[]> | prisma.City[]
  }
  techs: {
    type: 'Tech'
    args: Record<LeaderTechsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Leader">,
      args: { where?: TechWhereInput | null, orderBy?: prisma.TechOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech[]> | prisma.Tech[]
  }
  civics: {
    type: 'Civic'
    args: Record<LeaderCivicsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Leader">,
      args: { where?: CivicWhereInput | null, orderBy?: prisma.CivicOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic[]> | prisma.Civic[]
  }
  units: {
    type: 'Unit'
    args: Record<LeaderUnitsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Leader">,
      args: { where?: UnitWhereInput | null, orderBy?: prisma.UnitOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit[]> | prisma.Unit[]
  }
}
  

// Types for Player

type PlayerObject =
  | PlayerFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'isHuman', args?: [] | false, alias?: string  } 

type PlayerFields =
  | 'id'
  | 'name'
  | 'isHuman'



  

export interface PlayerFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'StringTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Player">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.StringTS[]> | prisma.StringTS[]
  }
  isHuman: {
    type: 'BooleanTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Player">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BooleanTS[]> | prisma.BooleanTS[]
  }
}
  

// Types for StringTS

type StringTSObject =
  | StringTSFields
  | { name: 'value', args?: [] | false, alias?: string  } 
  | { name: 'time', args?: [] | false, alias?: string  } 

type StringTSFields =
  | 'value'
  | 'time'



  

export interface StringTSFieldDetails {
  value: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  time: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for BooleanTS

type BooleanTSObject =
  | BooleanTSFields
  | { name: 'value', args?: [] | false, alias?: string  } 
  | { name: 'time', args?: [] | false, alias?: string  } 

type BooleanTSFields =
  | 'value'
  | 'time'



  

export interface BooleanTSFieldDetails {
  value: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  time: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for City

type CityObject =
  | CityFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'isExist', args?: [] | false, alias?: string  } 
  | { name: 'population', args?: [] | false, alias?: string  } 
  | { name: 'amenity', args?: [] | false, alias?: string  } 
  | { name: 'entertainment', args?: [] | false, alias?: string  } 
  | { name: 'location', args?: [] | false, alias?: string  } 

type CityFields =
  | 'id'
  | 'name'
  | 'isExist'
  | 'population'
  | 'amenity'
  | 'entertainment'
  | 'location'



  

export interface CityFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'StringTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"City">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.StringTS[]> | prisma.StringTS[]
  }
  isExist: {
    type: 'BooleanTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"City">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BooleanTS[]> | prisma.BooleanTS[]
  }
  population: {
    type: 'IntTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"City">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IntTS[]> | prisma.IntTS[]
  }
  amenity: {
    type: 'IntTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"City">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IntTS[]> | prisma.IntTS[]
  }
  entertainment: {
    type: 'IntTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"City">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IntTS[]> | prisma.IntTS[]
  }
  location: {
    type: 'TileTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"City">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TileTS[]> | prisma.TileTS[]
  }
}
  

// Types for IntTS

type IntTSObject =
  | IntTSFields
  | { name: 'value', args?: [] | false, alias?: string  } 
  | { name: 'time', args?: [] | false, alias?: string  } 

type IntTSFields =
  | 'value'
  | 'time'



  

export interface IntTSFieldDetails {
  value: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  time: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TileTS

type TileTSObject =
  | TileTSFields
  | { name: 'value', args?: [] | false, alias?: string  } 
  | { name: 'time', args?: [] | false, alias?: string  } 

type TileTSFields =
  | 'value'
  | 'time'



  

export interface TileTSFieldDetails {
  value: {
    type: 'Tile'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TileTS">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile> | prisma.Tile
  }
  time: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Tile

type TileObject =
  | TileFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'location', args?: [] | false, alias?: string  } 
  | { name: 'terrain', args?: [] | false, alias?: string  } 
  | { name: 'feature', args?: [] | false, alias?: string  } 

type TileFields =
  | 'id'
  | 'location'
  | 'terrain'
  | 'feature'



  

export interface TileFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  location: {
    type: 'Int'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  terrain: {
    type: 'IntTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Tile">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IntTS[]> | prisma.IntTS[]
  }
  feature: {
    type: 'IntTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Tile">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.IntTS[]> | prisma.IntTS[]
  }
}
  

// Types for Tech

type TechObject =
  | TechFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'type', args?: [] | false, alias?: string  } 
  | { name: 'progress', args?: [] | false, alias?: string  } 
  | { name: 'boosted', args?: [] | false, alias?: string  } 
  | { name: 'cost', args?: [] | false, alias?: string  } 

type TechFields =
  | 'id'
  | 'type'
  | 'progress'
  | 'boosted'
  | 'cost'



  

export interface TechFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  type: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  progress: {
    type: 'FloatTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Tech">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.FloatTS[]> | prisma.FloatTS[]
  }
  boosted: {
    type: 'BooleanTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Tech">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BooleanTS[]> | prisma.BooleanTS[]
  }
  cost: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for FloatTS

type FloatTSObject =
  | FloatTSFields
  | { name: 'value', args?: [] | false, alias?: string  } 
  | { name: 'time', args?: [] | false, alias?: string  } 

type FloatTSFields =
  | 'value'
  | 'time'



  

export interface FloatTSFieldDetails {
  value: {
    type: 'Float'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  time: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Civic

type CivicObject =
  | CivicFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'type', args?: [] | false, alias?: string  } 
  | { name: 'progress', args?: [] | false, alias?: string  } 
  | { name: 'boosted', args?: [] | false, alias?: string  } 
  | { name: 'cost', args?: [] | false, alias?: string  } 

type CivicFields =
  | 'id'
  | 'type'
  | 'progress'
  | 'boosted'
  | 'cost'



  

export interface CivicFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  type: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  progress: {
    type: 'FloatTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Civic">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.FloatTS[]> | prisma.FloatTS[]
  }
  boosted: {
    type: 'BooleanTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Civic">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BooleanTS[]> | prisma.BooleanTS[]
  }
  cost: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Unit

type UnitObject =
  | UnitFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'type', args?: [] | false, alias?: string  } 
  | { name: 'location', args?: [] | false, alias?: string  } 
  | { name: 'cost', args?: [] | false, alias?: string  } 
  | { name: 'baseMoves', args?: [] | false, alias?: string  } 
  | { name: 'combat', args?: [] | false, alias?: string  } 
  | { name: 'range', args?: [] | false, alias?: string  } 
  | { name: 'rangedCombar', args?: [] | false, alias?: string  } 
  | { name: 'bombard', args?: [] | false, alias?: string  } 

type UnitFields =
  | 'id'
  | 'type'
  | 'location'
  | 'cost'
  | 'baseMoves'
  | 'combat'
  | 'range'
  | 'rangedCombar'
  | 'bombard'



  

export interface UnitFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  type: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  location: {
    type: 'TileTS'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Unit">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TileTS[]> | prisma.TileTS[]
  }
  cost: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  baseMoves: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  combat: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  range: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  rangedCombar: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  bombard: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for Map

type MapObject =
  | MapFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'type', args?: [] | false, alias?: string  } 
  | { name: 'tiles', args?: MapTilesArgs[] | false, alias?: string  } 

type MapFields =
  | 'id'
  | 'type'
  | 'tiles'


type MapTilesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface MapFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  type: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  tiles: {
    type: 'Tile'
    args: Record<MapTilesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Map">,
      args: { where?: TileWhereInput | null, orderBy?: prisma.TileOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile[]> | prisma.Tile[]
  }
}
  

// Types for GameConnection

type GameConnectionObject =
  | GameConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type GameConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface GameConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"GameConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'GameEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"GameConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.GameEdge[]> | prisma.GameEdge[]
  }
  aggregate: {
    type: 'AggregateGame'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"GameConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateGame> | prisma.AggregateGame
  }
}
  

// Types for PageInfo

type PageInfoObject =
  | PageInfoFields
  | { name: 'hasNextPage', args?: [] | false, alias?: string  } 
  | { name: 'hasPreviousPage', args?: [] | false, alias?: string  } 
  | { name: 'startCursor', args?: [] | false, alias?: string  } 
  | { name: 'endCursor', args?: [] | false, alias?: string  } 

type PageInfoFields =
  | 'hasNextPage'
  | 'hasPreviousPage'
  | 'startCursor'
  | 'endCursor'



  

export interface PageInfoFieldDetails {
  hasNextPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  hasPreviousPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  endCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for GameEdge

type GameEdgeObject =
  | GameEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type GameEdgeFields =
  | 'node'
  | 'cursor'



  

export interface GameEdgeFieldDetails {
  node: {
    type: 'Game'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"GameEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Game> | prisma.Game
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateGame

type AggregateGameObject =
  | AggregateGameFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateGameFields =
  | 'count'



  

export interface AggregateGameFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for LeaderConnection

type LeaderConnectionObject =
  | LeaderConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type LeaderConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface LeaderConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"LeaderConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'LeaderEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"LeaderConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.LeaderEdge[]> | prisma.LeaderEdge[]
  }
  aggregate: {
    type: 'AggregateLeader'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"LeaderConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateLeader> | prisma.AggregateLeader
  }
}
  

// Types for LeaderEdge

type LeaderEdgeObject =
  | LeaderEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type LeaderEdgeFields =
  | 'node'
  | 'cursor'



  

export interface LeaderEdgeFieldDetails {
  node: {
    type: 'Leader'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"LeaderEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader> | prisma.Leader
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateLeader

type AggregateLeaderObject =
  | AggregateLeaderFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateLeaderFields =
  | 'count'



  

export interface AggregateLeaderFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for PlayerConnection

type PlayerConnectionObject =
  | PlayerConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type PlayerConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface PlayerConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"PlayerConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'PlayerEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"PlayerConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PlayerEdge[]> | prisma.PlayerEdge[]
  }
  aggregate: {
    type: 'AggregatePlayer'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"PlayerConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregatePlayer> | prisma.AggregatePlayer
  }
}
  

// Types for PlayerEdge

type PlayerEdgeObject =
  | PlayerEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type PlayerEdgeFields =
  | 'node'
  | 'cursor'



  

export interface PlayerEdgeFieldDetails {
  node: {
    type: 'Player'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"PlayerEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player> | prisma.Player
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregatePlayer

type AggregatePlayerObject =
  | AggregatePlayerFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregatePlayerFields =
  | 'count'



  

export interface AggregatePlayerFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CityConnection

type CityConnectionObject =
  | CityConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type CityConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface CityConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CityConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'CityEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"CityConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CityEdge[]> | prisma.CityEdge[]
  }
  aggregate: {
    type: 'AggregateCity'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CityConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateCity> | prisma.AggregateCity
  }
}
  

// Types for CityEdge

type CityEdgeObject =
  | CityEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type CityEdgeFields =
  | 'node'
  | 'cursor'



  

export interface CityEdgeFieldDetails {
  node: {
    type: 'City'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CityEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City> | prisma.City
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateCity

type AggregateCityObject =
  | AggregateCityFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateCityFields =
  | 'count'



  

export interface AggregateCityFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for UnitConnection

type UnitConnectionObject =
  | UnitConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type UnitConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface UnitConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UnitConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'UnitEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"UnitConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UnitEdge[]> | prisma.UnitEdge[]
  }
  aggregate: {
    type: 'AggregateUnit'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UnitConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateUnit> | prisma.AggregateUnit
  }
}
  

// Types for UnitEdge

type UnitEdgeObject =
  | UnitEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type UnitEdgeFields =
  | 'node'
  | 'cursor'



  

export interface UnitEdgeFieldDetails {
  node: {
    type: 'Unit'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UnitEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit> | prisma.Unit
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateUnit

type AggregateUnitObject =
  | AggregateUnitFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateUnitFields =
  | 'count'



  

export interface AggregateUnitFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TechConnection

type TechConnectionObject =
  | TechConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type TechConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface TechConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TechConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'TechEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"TechConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TechEdge[]> | prisma.TechEdge[]
  }
  aggregate: {
    type: 'AggregateTech'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TechConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateTech> | prisma.AggregateTech
  }
}
  

// Types for TechEdge

type TechEdgeObject =
  | TechEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type TechEdgeFields =
  | 'node'
  | 'cursor'



  

export interface TechEdgeFieldDetails {
  node: {
    type: 'Tech'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TechEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech> | prisma.Tech
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateTech

type AggregateTechObject =
  | AggregateTechFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateTechFields =
  | 'count'



  

export interface AggregateTechFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CivicConnection

type CivicConnectionObject =
  | CivicConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type CivicConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface CivicConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CivicConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'CivicEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"CivicConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CivicEdge[]> | prisma.CivicEdge[]
  }
  aggregate: {
    type: 'AggregateCivic'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CivicConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateCivic> | prisma.AggregateCivic
  }
}
  

// Types for CivicEdge

type CivicEdgeObject =
  | CivicEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type CivicEdgeFields =
  | 'node'
  | 'cursor'



  

export interface CivicEdgeFieldDetails {
  node: {
    type: 'Civic'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CivicEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic> | prisma.Civic
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateCivic

type AggregateCivicObject =
  | AggregateCivicFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateCivicFields =
  | 'count'



  

export interface AggregateCivicFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for MapConnection

type MapConnectionObject =
  | MapConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type MapConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface MapConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"MapConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'MapEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"MapConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MapEdge[]> | prisma.MapEdge[]
  }
  aggregate: {
    type: 'AggregateMap'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"MapConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateMap> | prisma.AggregateMap
  }
}
  

// Types for MapEdge

type MapEdgeObject =
  | MapEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type MapEdgeFields =
  | 'node'
  | 'cursor'



  

export interface MapEdgeFieldDetails {
  node: {
    type: 'Map'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"MapEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map> | prisma.Map
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateMap

type AggregateMapObject =
  | AggregateMapFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateMapFields =
  | 'count'



  

export interface AggregateMapFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TileConnection

type TileConnectionObject =
  | TileConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type TileConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface TileConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TileConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'TileEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"TileConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TileEdge[]> | prisma.TileEdge[]
  }
  aggregate: {
    type: 'AggregateTile'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TileConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateTile> | prisma.AggregateTile
  }
}
  

// Types for TileEdge

type TileEdgeObject =
  | TileEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type TileEdgeFields =
  | 'node'
  | 'cursor'



  

export interface TileEdgeFieldDetails {
  node: {
    type: 'Tile'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TileEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile> | prisma.Tile
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateTile

type AggregateTileObject =
  | AggregateTileFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateTileFields =
  | 'count'



  

export interface AggregateTileFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Mutation

type MutationObject =
  | MutationFields
  | { name: 'createGame', args?: MutationCreateGameArgs[] | false, alias?: string  } 
  | { name: 'updateGame', args?: MutationUpdateGameArgs[] | false, alias?: string  } 
  | { name: 'updateManyGames', args?: MutationUpdateManyGamesArgs[] | false, alias?: string  } 
  | { name: 'upsertGame', args?: MutationUpsertGameArgs[] | false, alias?: string  } 
  | { name: 'deleteGame', args?: MutationDeleteGameArgs[] | false, alias?: string  } 
  | { name: 'deleteManyGames', args?: MutationDeleteManyGamesArgs[] | false, alias?: string  } 
  | { name: 'createLeader', args?: MutationCreateLeaderArgs[] | false, alias?: string  } 
  | { name: 'updateLeader', args?: MutationUpdateLeaderArgs[] | false, alias?: string  } 
  | { name: 'updateManyLeaders', args?: MutationUpdateManyLeadersArgs[] | false, alias?: string  } 
  | { name: 'upsertLeader', args?: MutationUpsertLeaderArgs[] | false, alias?: string  } 
  | { name: 'deleteLeader', args?: MutationDeleteLeaderArgs[] | false, alias?: string  } 
  | { name: 'deleteManyLeaders', args?: MutationDeleteManyLeadersArgs[] | false, alias?: string  } 
  | { name: 'createPlayer', args?: MutationCreatePlayerArgs[] | false, alias?: string  } 
  | { name: 'updatePlayer', args?: MutationUpdatePlayerArgs[] | false, alias?: string  } 
  | { name: 'upsertPlayer', args?: MutationUpsertPlayerArgs[] | false, alias?: string  } 
  | { name: 'deletePlayer', args?: MutationDeletePlayerArgs[] | false, alias?: string  } 
  | { name: 'deleteManyPlayers', args?: MutationDeleteManyPlayersArgs[] | false, alias?: string  } 
  | { name: 'createCity', args?: MutationCreateCityArgs[] | false, alias?: string  } 
  | { name: 'updateCity', args?: MutationUpdateCityArgs[] | false, alias?: string  } 
  | { name: 'upsertCity', args?: MutationUpsertCityArgs[] | false, alias?: string  } 
  | { name: 'deleteCity', args?: MutationDeleteCityArgs[] | false, alias?: string  } 
  | { name: 'deleteManyCities', args?: MutationDeleteManyCitiesArgs[] | false, alias?: string  } 
  | { name: 'createUnit', args?: MutationCreateUnitArgs[] | false, alias?: string  } 
  | { name: 'updateUnit', args?: MutationUpdateUnitArgs[] | false, alias?: string  } 
  | { name: 'updateManyUnits', args?: MutationUpdateManyUnitsArgs[] | false, alias?: string  } 
  | { name: 'upsertUnit', args?: MutationUpsertUnitArgs[] | false, alias?: string  } 
  | { name: 'deleteUnit', args?: MutationDeleteUnitArgs[] | false, alias?: string  } 
  | { name: 'deleteManyUnits', args?: MutationDeleteManyUnitsArgs[] | false, alias?: string  } 
  | { name: 'createTech', args?: MutationCreateTechArgs[] | false, alias?: string  } 
  | { name: 'updateTech', args?: MutationUpdateTechArgs[] | false, alias?: string  } 
  | { name: 'updateManyTeches', args?: MutationUpdateManyTechesArgs[] | false, alias?: string  } 
  | { name: 'upsertTech', args?: MutationUpsertTechArgs[] | false, alias?: string  } 
  | { name: 'deleteTech', args?: MutationDeleteTechArgs[] | false, alias?: string  } 
  | { name: 'deleteManyTeches', args?: MutationDeleteManyTechesArgs[] | false, alias?: string  } 
  | { name: 'createCivic', args?: MutationCreateCivicArgs[] | false, alias?: string  } 
  | { name: 'updateCivic', args?: MutationUpdateCivicArgs[] | false, alias?: string  } 
  | { name: 'updateManyCivics', args?: MutationUpdateManyCivicsArgs[] | false, alias?: string  } 
  | { name: 'upsertCivic', args?: MutationUpsertCivicArgs[] | false, alias?: string  } 
  | { name: 'deleteCivic', args?: MutationDeleteCivicArgs[] | false, alias?: string  } 
  | { name: 'deleteManyCivics', args?: MutationDeleteManyCivicsArgs[] | false, alias?: string  } 
  | { name: 'createMap', args?: MutationCreateMapArgs[] | false, alias?: string  } 
  | { name: 'updateMap', args?: MutationUpdateMapArgs[] | false, alias?: string  } 
  | { name: 'updateManyMaps', args?: MutationUpdateManyMapsArgs[] | false, alias?: string  } 
  | { name: 'upsertMap', args?: MutationUpsertMapArgs[] | false, alias?: string  } 
  | { name: 'deleteMap', args?: MutationDeleteMapArgs[] | false, alias?: string  } 
  | { name: 'deleteManyMaps', args?: MutationDeleteManyMapsArgs[] | false, alias?: string  } 
  | { name: 'createTile', args?: MutationCreateTileArgs[] | false, alias?: string  } 
  | { name: 'updateTile', args?: MutationUpdateTileArgs[] | false, alias?: string  } 
  | { name: 'updateManyTiles', args?: MutationUpdateManyTilesArgs[] | false, alias?: string  } 
  | { name: 'upsertTile', args?: MutationUpsertTileArgs[] | false, alias?: string  } 
  | { name: 'deleteTile', args?: MutationDeleteTileArgs[] | false, alias?: string  } 
  | { name: 'deleteManyTiles', args?: MutationDeleteManyTilesArgs[] | false, alias?: string  } 

type MutationFields =
  | 'createGame'
  | 'updateGame'
  | 'updateManyGames'
  | 'upsertGame'
  | 'deleteGame'
  | 'deleteManyGames'
  | 'createLeader'
  | 'updateLeader'
  | 'updateManyLeaders'
  | 'upsertLeader'
  | 'deleteLeader'
  | 'deleteManyLeaders'
  | 'createPlayer'
  | 'updatePlayer'
  | 'upsertPlayer'
  | 'deletePlayer'
  | 'deleteManyPlayers'
  | 'createCity'
  | 'updateCity'
  | 'upsertCity'
  | 'deleteCity'
  | 'deleteManyCities'
  | 'createUnit'
  | 'updateUnit'
  | 'updateManyUnits'
  | 'upsertUnit'
  | 'deleteUnit'
  | 'deleteManyUnits'
  | 'createTech'
  | 'updateTech'
  | 'updateManyTeches'
  | 'upsertTech'
  | 'deleteTech'
  | 'deleteManyTeches'
  | 'createCivic'
  | 'updateCivic'
  | 'updateManyCivics'
  | 'upsertCivic'
  | 'deleteCivic'
  | 'deleteManyCivics'
  | 'createMap'
  | 'updateMap'
  | 'updateManyMaps'
  | 'upsertMap'
  | 'deleteMap'
  | 'deleteManyMaps'
  | 'createTile'
  | 'updateTile'
  | 'updateManyTiles'
  | 'upsertTile'
  | 'deleteTile'
  | 'deleteManyTiles'


type MutationCreateGameArgs =
  | 'data'
type MutationUpdateGameArgs =
  | 'data'
  | 'where'
type MutationUpdateManyGamesArgs =
  | 'data'
  | 'where'
type MutationUpsertGameArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteGameArgs =
  | 'where'
type MutationDeleteManyGamesArgs =
  | 'where'
type MutationCreateLeaderArgs =
  | 'data'
type MutationUpdateLeaderArgs =
  | 'data'
  | 'where'
type MutationUpdateManyLeadersArgs =
  | 'data'
  | 'where'
type MutationUpsertLeaderArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteLeaderArgs =
  | 'where'
type MutationDeleteManyLeadersArgs =
  | 'where'
type MutationCreatePlayerArgs =
  | 'data'
type MutationUpdatePlayerArgs =
  | 'data'
  | 'where'
type MutationUpsertPlayerArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeletePlayerArgs =
  | 'where'
type MutationDeleteManyPlayersArgs =
  | 'where'
type MutationCreateCityArgs =
  | 'data'
type MutationUpdateCityArgs =
  | 'data'
  | 'where'
type MutationUpsertCityArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteCityArgs =
  | 'where'
type MutationDeleteManyCitiesArgs =
  | 'where'
type MutationCreateUnitArgs =
  | 'data'
type MutationUpdateUnitArgs =
  | 'data'
  | 'where'
type MutationUpdateManyUnitsArgs =
  | 'data'
  | 'where'
type MutationUpsertUnitArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteUnitArgs =
  | 'where'
type MutationDeleteManyUnitsArgs =
  | 'where'
type MutationCreateTechArgs =
  | 'data'
type MutationUpdateTechArgs =
  | 'data'
  | 'where'
type MutationUpdateManyTechesArgs =
  | 'data'
  | 'where'
type MutationUpsertTechArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteTechArgs =
  | 'where'
type MutationDeleteManyTechesArgs =
  | 'where'
type MutationCreateCivicArgs =
  | 'data'
type MutationUpdateCivicArgs =
  | 'data'
  | 'where'
type MutationUpdateManyCivicsArgs =
  | 'data'
  | 'where'
type MutationUpsertCivicArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteCivicArgs =
  | 'where'
type MutationDeleteManyCivicsArgs =
  | 'where'
type MutationCreateMapArgs =
  | 'data'
type MutationUpdateMapArgs =
  | 'data'
  | 'where'
type MutationUpdateManyMapsArgs =
  | 'data'
  | 'where'
type MutationUpsertMapArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteMapArgs =
  | 'where'
type MutationDeleteManyMapsArgs =
  | 'where'
type MutationCreateTileArgs =
  | 'data'
type MutationUpdateTileArgs =
  | 'data'
  | 'where'
type MutationUpdateManyTilesArgs =
  | 'data'
  | 'where'
type MutationUpsertTileArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteTileArgs =
  | 'where'
type MutationDeleteManyTilesArgs =
  | 'where'
  

export interface MutationFieldDetails {
  createGame: {
    type: 'Game'
    args: Record<MutationCreateGameArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: GameCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Game> | prisma.Game
  }
  updateGame: {
    type: 'Game'
    args: Record<MutationUpdateGameArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: GameUpdateInput, where: GameWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Game | null> | prisma.Game | null
  }
  updateManyGames: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyGamesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: GameUpdateManyMutationInput, where?: GameWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertGame: {
    type: 'Game'
    args: Record<MutationUpsertGameArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: GameWhereUniqueInput, create: GameCreateInput, update: GameUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Game> | prisma.Game
  }
  deleteGame: {
    type: 'Game'
    args: Record<MutationDeleteGameArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: GameWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Game | null> | prisma.Game | null
  }
  deleteManyGames: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyGamesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: GameWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createLeader: {
    type: 'Leader'
    args: Record<MutationCreateLeaderArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: LeaderCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader> | prisma.Leader
  }
  updateLeader: {
    type: 'Leader'
    args: Record<MutationUpdateLeaderArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: LeaderUpdateInput, where: LeaderWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader | null> | prisma.Leader | null
  }
  updateManyLeaders: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyLeadersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: LeaderUpdateManyMutationInput, where?: LeaderWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertLeader: {
    type: 'Leader'
    args: Record<MutationUpsertLeaderArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: LeaderWhereUniqueInput, create: LeaderCreateInput, update: LeaderUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader> | prisma.Leader
  }
  deleteLeader: {
    type: 'Leader'
    args: Record<MutationDeleteLeaderArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: LeaderWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader | null> | prisma.Leader | null
  }
  deleteManyLeaders: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyLeadersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: LeaderWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createPlayer: {
    type: 'Player'
    args: Record<MutationCreatePlayerArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: PlayerCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player> | prisma.Player
  }
  updatePlayer: {
    type: 'Player'
    args: Record<MutationUpdatePlayerArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: PlayerUpdateInput, where: PlayerWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player | null> | prisma.Player | null
  }
  upsertPlayer: {
    type: 'Player'
    args: Record<MutationUpsertPlayerArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: PlayerWhereUniqueInput, create: PlayerCreateInput, update: PlayerUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player> | prisma.Player
  }
  deletePlayer: {
    type: 'Player'
    args: Record<MutationDeletePlayerArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: PlayerWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player | null> | prisma.Player | null
  }
  deleteManyPlayers: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyPlayersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: PlayerWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createCity: {
    type: 'City'
    args: Record<MutationCreateCityArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CityCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City> | prisma.City
  }
  updateCity: {
    type: 'City'
    args: Record<MutationUpdateCityArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CityUpdateInput, where: CityWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City | null> | prisma.City | null
  }
  upsertCity: {
    type: 'City'
    args: Record<MutationUpsertCityArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CityWhereUniqueInput, create: CityCreateInput, update: CityUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City> | prisma.City
  }
  deleteCity: {
    type: 'City'
    args: Record<MutationDeleteCityArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CityWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City | null> | prisma.City | null
  }
  deleteManyCities: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyCitiesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: CityWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createUnit: {
    type: 'Unit'
    args: Record<MutationCreateUnitArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UnitCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit> | prisma.Unit
  }
  updateUnit: {
    type: 'Unit'
    args: Record<MutationUpdateUnitArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UnitUpdateInput, where: UnitWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit | null> | prisma.Unit | null
  }
  updateManyUnits: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyUnitsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UnitUpdateManyMutationInput, where?: UnitWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertUnit: {
    type: 'Unit'
    args: Record<MutationUpsertUnitArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UnitWhereUniqueInput, create: UnitCreateInput, update: UnitUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit> | prisma.Unit
  }
  deleteUnit: {
    type: 'Unit'
    args: Record<MutationDeleteUnitArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UnitWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit | null> | prisma.Unit | null
  }
  deleteManyUnits: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyUnitsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: UnitWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createTech: {
    type: 'Tech'
    args: Record<MutationCreateTechArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TechCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech> | prisma.Tech
  }
  updateTech: {
    type: 'Tech'
    args: Record<MutationUpdateTechArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TechUpdateInput, where: TechWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech | null> | prisma.Tech | null
  }
  updateManyTeches: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyTechesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TechUpdateManyMutationInput, where?: TechWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertTech: {
    type: 'Tech'
    args: Record<MutationUpsertTechArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TechWhereUniqueInput, create: TechCreateInput, update: TechUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech> | prisma.Tech
  }
  deleteTech: {
    type: 'Tech'
    args: Record<MutationDeleteTechArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TechWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech | null> | prisma.Tech | null
  }
  deleteManyTeches: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyTechesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: TechWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createCivic: {
    type: 'Civic'
    args: Record<MutationCreateCivicArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CivicCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic> | prisma.Civic
  }
  updateCivic: {
    type: 'Civic'
    args: Record<MutationUpdateCivicArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CivicUpdateInput, where: CivicWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic | null> | prisma.Civic | null
  }
  updateManyCivics: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyCivicsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CivicUpdateManyMutationInput, where?: CivicWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertCivic: {
    type: 'Civic'
    args: Record<MutationUpsertCivicArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CivicWhereUniqueInput, create: CivicCreateInput, update: CivicUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic> | prisma.Civic
  }
  deleteCivic: {
    type: 'Civic'
    args: Record<MutationDeleteCivicArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CivicWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic | null> | prisma.Civic | null
  }
  deleteManyCivics: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyCivicsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: CivicWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createMap: {
    type: 'Map'
    args: Record<MutationCreateMapArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: MapCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map> | prisma.Map
  }
  updateMap: {
    type: 'Map'
    args: Record<MutationUpdateMapArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: MapUpdateInput, where: MapWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map | null> | prisma.Map | null
  }
  updateManyMaps: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyMapsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: MapUpdateManyMutationInput, where?: MapWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertMap: {
    type: 'Map'
    args: Record<MutationUpsertMapArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: MapWhereUniqueInput, create: MapCreateInput, update: MapUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map> | prisma.Map
  }
  deleteMap: {
    type: 'Map'
    args: Record<MutationDeleteMapArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: MapWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map | null> | prisma.Map | null
  }
  deleteManyMaps: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyMapsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: MapWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createTile: {
    type: 'Tile'
    args: Record<MutationCreateTileArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TileCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile> | prisma.Tile
  }
  updateTile: {
    type: 'Tile'
    args: Record<MutationUpdateTileArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TileUpdateInput, where: TileWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile | null> | prisma.Tile | null
  }
  updateManyTiles: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyTilesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TileUpdateManyMutationInput, where?: TileWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertTile: {
    type: 'Tile'
    args: Record<MutationUpsertTileArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TileWhereUniqueInput, create: TileCreateInput, update: TileUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile> | prisma.Tile
  }
  deleteTile: {
    type: 'Tile'
    args: Record<MutationDeleteTileArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TileWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile | null> | prisma.Tile | null
  }
  deleteManyTiles: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyTilesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: TileWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
}
  

// Types for BatchPayload

type BatchPayloadObject =
  | BatchPayloadFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type BatchPayloadFields =
  | 'count'



  

export interface BatchPayloadFieldDetails {
  count: {
    type: 'Long'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Subscription

type SubscriptionObject =
  | SubscriptionFields
  | { name: 'game', args?: SubscriptionGameArgs[] | false, alias?: string  } 
  | { name: 'leader', args?: SubscriptionLeaderArgs[] | false, alias?: string  } 
  | { name: 'player', args?: SubscriptionPlayerArgs[] | false, alias?: string  } 
  | { name: 'city', args?: SubscriptionCityArgs[] | false, alias?: string  } 
  | { name: 'unit', args?: SubscriptionUnitArgs[] | false, alias?: string  } 
  | { name: 'tech', args?: SubscriptionTechArgs[] | false, alias?: string  } 
  | { name: 'civic', args?: SubscriptionCivicArgs[] | false, alias?: string  } 
  | { name: 'map', args?: SubscriptionMapArgs[] | false, alias?: string  } 
  | { name: 'tile', args?: SubscriptionTileArgs[] | false, alias?: string  } 

type SubscriptionFields =
  | 'game'
  | 'leader'
  | 'player'
  | 'city'
  | 'unit'
  | 'tech'
  | 'civic'
  | 'map'
  | 'tile'


type SubscriptionGameArgs =
  | 'where'
type SubscriptionLeaderArgs =
  | 'where'
type SubscriptionPlayerArgs =
  | 'where'
type SubscriptionCityArgs =
  | 'where'
type SubscriptionUnitArgs =
  | 'where'
type SubscriptionTechArgs =
  | 'where'
type SubscriptionCivicArgs =
  | 'where'
type SubscriptionMapArgs =
  | 'where'
type SubscriptionTileArgs =
  | 'where'
  

export interface SubscriptionFieldDetails {
  game: {
    type: 'GameSubscriptionPayload'
    args: Record<SubscriptionGameArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: GameSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.GameSubscriptionPayload | null> | prisma.GameSubscriptionPayload | null
  }
  leader: {
    type: 'LeaderSubscriptionPayload'
    args: Record<SubscriptionLeaderArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: LeaderSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.LeaderSubscriptionPayload | null> | prisma.LeaderSubscriptionPayload | null
  }
  player: {
    type: 'PlayerSubscriptionPayload'
    args: Record<SubscriptionPlayerArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: PlayerSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PlayerSubscriptionPayload | null> | prisma.PlayerSubscriptionPayload | null
  }
  city: {
    type: 'CitySubscriptionPayload'
    args: Record<SubscriptionCityArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: CitySubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CitySubscriptionPayload | null> | prisma.CitySubscriptionPayload | null
  }
  unit: {
    type: 'UnitSubscriptionPayload'
    args: Record<SubscriptionUnitArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: UnitSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UnitSubscriptionPayload | null> | prisma.UnitSubscriptionPayload | null
  }
  tech: {
    type: 'TechSubscriptionPayload'
    args: Record<SubscriptionTechArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: TechSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TechSubscriptionPayload | null> | prisma.TechSubscriptionPayload | null
  }
  civic: {
    type: 'CivicSubscriptionPayload'
    args: Record<SubscriptionCivicArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: CivicSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CivicSubscriptionPayload | null> | prisma.CivicSubscriptionPayload | null
  }
  map: {
    type: 'MapSubscriptionPayload'
    args: Record<SubscriptionMapArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: MapSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MapSubscriptionPayload | null> | prisma.MapSubscriptionPayload | null
  }
  tile: {
    type: 'TileSubscriptionPayload'
    args: Record<SubscriptionTileArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: TileSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TileSubscriptionPayload | null> | prisma.TileSubscriptionPayload | null
  }
}
  

// Types for GameSubscriptionPayload

type GameSubscriptionPayloadObject =
  | GameSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type GameSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface GameSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"GameSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Game'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"GameSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Game | null> | prisma.Game | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'GamePreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"GameSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.GamePreviousValues | null> | prisma.GamePreviousValues | null
  }
}
  

// Types for GamePreviousValues

type GamePreviousValuesObject =
  | GamePreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type GamePreviousValuesFields =
  | 'id'
  | 'name'



  

export interface GamePreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for LeaderSubscriptionPayload

type LeaderSubscriptionPayloadObject =
  | LeaderSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type LeaderSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface LeaderSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"LeaderSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Leader'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"LeaderSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Leader | null> | prisma.Leader | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'LeaderPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"LeaderSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.LeaderPreviousValues | null> | prisma.LeaderPreviousValues | null
  }
}
  

// Types for LeaderPreviousValues

type LeaderPreviousValuesObject =
  | LeaderPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type LeaderPreviousValuesFields =
  | 'id'
  | 'name'



  

export interface LeaderPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for PlayerSubscriptionPayload

type PlayerSubscriptionPayloadObject =
  | PlayerSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type PlayerSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface PlayerSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"PlayerSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Player'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"PlayerSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Player | null> | prisma.Player | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'PlayerPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"PlayerSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PlayerPreviousValues | null> | prisma.PlayerPreviousValues | null
  }
}
  

// Types for PlayerPreviousValues

type PlayerPreviousValuesObject =
  | PlayerPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 

type PlayerPreviousValuesFields =
  | 'id'



  

export interface PlayerPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CitySubscriptionPayload

type CitySubscriptionPayloadObject =
  | CitySubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type CitySubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface CitySubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CitySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'City'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CitySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.City | null> | prisma.City | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'CityPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CitySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CityPreviousValues | null> | prisma.CityPreviousValues | null
  }
}
  

// Types for CityPreviousValues

type CityPreviousValuesObject =
  | CityPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 

type CityPreviousValuesFields =
  | 'id'



  

export interface CityPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for UnitSubscriptionPayload

type UnitSubscriptionPayloadObject =
  | UnitSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type UnitSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface UnitSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UnitSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Unit'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UnitSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Unit | null> | prisma.Unit | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'UnitPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UnitSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UnitPreviousValues | null> | prisma.UnitPreviousValues | null
  }
}
  

// Types for UnitPreviousValues

type UnitPreviousValuesObject =
  | UnitPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'type', args?: [] | false, alias?: string  } 
  | { name: 'cost', args?: [] | false, alias?: string  } 
  | { name: 'baseMoves', args?: [] | false, alias?: string  } 
  | { name: 'combat', args?: [] | false, alias?: string  } 
  | { name: 'range', args?: [] | false, alias?: string  } 
  | { name: 'rangedCombar', args?: [] | false, alias?: string  } 
  | { name: 'bombard', args?: [] | false, alias?: string  } 

type UnitPreviousValuesFields =
  | 'id'
  | 'type'
  | 'cost'
  | 'baseMoves'
  | 'combat'
  | 'range'
  | 'rangedCombar'
  | 'bombard'



  

export interface UnitPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  type: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  cost: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  baseMoves: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  combat: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  range: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  rangedCombar: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  bombard: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for TechSubscriptionPayload

type TechSubscriptionPayloadObject =
  | TechSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type TechSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface TechSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TechSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Tech'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TechSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tech | null> | prisma.Tech | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'TechPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TechSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TechPreviousValues | null> | prisma.TechPreviousValues | null
  }
}
  

// Types for TechPreviousValues

type TechPreviousValuesObject =
  | TechPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'type', args?: [] | false, alias?: string  } 
  | { name: 'cost', args?: [] | false, alias?: string  } 

type TechPreviousValuesFields =
  | 'id'
  | 'type'
  | 'cost'



  

export interface TechPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  type: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  cost: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CivicSubscriptionPayload

type CivicSubscriptionPayloadObject =
  | CivicSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type CivicSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface CivicSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CivicSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Civic'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CivicSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Civic | null> | prisma.Civic | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'CivicPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CivicSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CivicPreviousValues | null> | prisma.CivicPreviousValues | null
  }
}
  

// Types for CivicPreviousValues

type CivicPreviousValuesObject =
  | CivicPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'type', args?: [] | false, alias?: string  } 
  | { name: 'cost', args?: [] | false, alias?: string  } 

type CivicPreviousValuesFields =
  | 'id'
  | 'type'
  | 'cost'



  

export interface CivicPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  type: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  cost: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for MapSubscriptionPayload

type MapSubscriptionPayloadObject =
  | MapSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type MapSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface MapSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"MapSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Map'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"MapSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Map | null> | prisma.Map | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'MapPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"MapSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MapPreviousValues | null> | prisma.MapPreviousValues | null
  }
}
  

// Types for MapPreviousValues

type MapPreviousValuesObject =
  | MapPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'type', args?: [] | false, alias?: string  } 

type MapPreviousValuesFields =
  | 'id'
  | 'type'



  

export interface MapPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  type: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TileSubscriptionPayload

type TileSubscriptionPayloadObject =
  | TileSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type TileSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface TileSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TileSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Tile'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TileSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tile | null> | prisma.Tile | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'TilePreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TileSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TilePreviousValues | null> | prisma.TilePreviousValues | null
  }
}
  

// Types for TilePreviousValues

type TilePreviousValuesObject =
  | TilePreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'location', args?: [] | false, alias?: string  } 

type TilePreviousValuesFields =
  | 'id'
  | 'location'



  

export interface TilePreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  location: {
    type: 'Int'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
}
  


export interface GameWhereUniqueInput {
  id?: string | null
}
export type GameWhereUniqueInputInputObject =
  | Extract<keyof GameWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface LeaderWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  player?: PlayerWhereInput | null
  cities_some?: CityWhereInput | null
  techs_some?: TechWhereInput | null
  civics_some?: CivicWhereInput | null
  units_some?: UnitWhereInput | null
  AND?: LeaderWhereInput[]
}
export type LeaderWhereInputInputObject =
  | Extract<keyof LeaderWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'player', alias?: string  } 
  | { name: 'cities_some', alias?: string  } 
  | { name: 'techs_some', alias?: string  } 
  | { name: 'civics_some', alias?: string  } 
  | { name: 'units_some', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface PlayerWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name_some?: StringTSWhereInput | null
  name_every?: StringTSRestrictedWhereInput | null
  name_none?: StringTSRestrictedWhereInput | null
  isHuman_some?: BooleanTSWhereInput | null
  isHuman_every?: BooleanTSRestrictedWhereInput | null
  isHuman_none?: BooleanTSRestrictedWhereInput | null
  AND?: PlayerWhereInput[]
}
export type PlayerWhereInputInputObject =
  | Extract<keyof PlayerWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name_some', alias?: string  } 
  | { name: 'name_every', alias?: string  } 
  | { name: 'name_none', alias?: string  } 
  | { name: 'isHuman_some', alias?: string  } 
  | { name: 'isHuman_every', alias?: string  } 
  | { name: 'isHuman_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface StringTSWhereInput {
  value?: string | null
  value_not?: string | null
  value_in?: string[]
  value_not_in?: string[]
  value_lt?: string | null
  value_lte?: string | null
  value_gt?: string | null
  value_gte?: string | null
  value_contains?: string | null
  value_not_contains?: string | null
  value_starts_with?: string | null
  value_not_starts_with?: string | null
  value_ends_with?: string | null
  value_not_ends_with?: string | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: StringTSWhereInput[]
}
export type StringTSWhereInputInputObject =
  | Extract<keyof StringTSWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'value_contains', alias?: string  } 
  | { name: 'value_not_contains', alias?: string  } 
  | { name: 'value_starts_with', alias?: string  } 
  | { name: 'value_not_starts_with', alias?: string  } 
  | { name: 'value_ends_with', alias?: string  } 
  | { name: 'value_not_ends_with', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface StringTSRestrictedWhereInput {
  value?: string | null
  value_not?: string | null
  value_in?: string[]
  value_not_in?: string[]
  value_lt?: string | null
  value_lte?: string | null
  value_gt?: string | null
  value_gte?: string | null
  value_contains?: string | null
  value_not_contains?: string | null
  value_starts_with?: string | null
  value_not_starts_with?: string | null
  value_ends_with?: string | null
  value_not_ends_with?: string | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: StringTSRestrictedWhereInput[]
}
export type StringTSRestrictedWhereInputInputObject =
  | Extract<keyof StringTSRestrictedWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'value_contains', alias?: string  } 
  | { name: 'value_not_contains', alias?: string  } 
  | { name: 'value_starts_with', alias?: string  } 
  | { name: 'value_not_starts_with', alias?: string  } 
  | { name: 'value_ends_with', alias?: string  } 
  | { name: 'value_not_ends_with', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface BooleanTSWhereInput {
  value?: boolean | null
  value_not?: boolean | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: BooleanTSWhereInput[]
}
export type BooleanTSWhereInputInputObject =
  | Extract<keyof BooleanTSWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface BooleanTSRestrictedWhereInput {
  value?: boolean | null
  value_not?: boolean | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: BooleanTSRestrictedWhereInput[]
}
export type BooleanTSRestrictedWhereInputInputObject =
  | Extract<keyof BooleanTSRestrictedWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface CityWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name_some?: StringTSWhereInput | null
  name_every?: StringTSRestrictedWhereInput | null
  name_none?: StringTSRestrictedWhereInput | null
  isExist_some?: BooleanTSWhereInput | null
  isExist_every?: BooleanTSRestrictedWhereInput | null
  isExist_none?: BooleanTSRestrictedWhereInput | null
  population_some?: IntTSWhereInput | null
  population_every?: IntTSRestrictedWhereInput | null
  population_none?: IntTSRestrictedWhereInput | null
  amenity_some?: IntTSWhereInput | null
  amenity_every?: IntTSRestrictedWhereInput | null
  amenity_none?: IntTSRestrictedWhereInput | null
  entertainment_some?: IntTSWhereInput | null
  entertainment_every?: IntTSRestrictedWhereInput | null
  entertainment_none?: IntTSRestrictedWhereInput | null
  location_some?: TileTSWhereInput | null
  location_every?: TileTSRestrictedWhereInput | null
  location_none?: TileTSRestrictedWhereInput | null
  AND?: CityWhereInput[]
}
export type CityWhereInputInputObject =
  | Extract<keyof CityWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name_some', alias?: string  } 
  | { name: 'name_every', alias?: string  } 
  | { name: 'name_none', alias?: string  } 
  | { name: 'isExist_some', alias?: string  } 
  | { name: 'isExist_every', alias?: string  } 
  | { name: 'isExist_none', alias?: string  } 
  | { name: 'population_some', alias?: string  } 
  | { name: 'population_every', alias?: string  } 
  | { name: 'population_none', alias?: string  } 
  | { name: 'amenity_some', alias?: string  } 
  | { name: 'amenity_every', alias?: string  } 
  | { name: 'amenity_none', alias?: string  } 
  | { name: 'entertainment_some', alias?: string  } 
  | { name: 'entertainment_every', alias?: string  } 
  | { name: 'entertainment_none', alias?: string  } 
  | { name: 'location_some', alias?: string  } 
  | { name: 'location_every', alias?: string  } 
  | { name: 'location_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface IntTSWhereInput {
  value?: number | null
  value_not?: number | null
  value_in?: number[]
  value_not_in?: number[]
  value_lt?: number | null
  value_lte?: number | null
  value_gt?: number | null
  value_gte?: number | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: IntTSWhereInput[]
}
export type IntTSWhereInputInputObject =
  | Extract<keyof IntTSWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface IntTSRestrictedWhereInput {
  value?: number | null
  value_not?: number | null
  value_in?: number[]
  value_not_in?: number[]
  value_lt?: number | null
  value_lte?: number | null
  value_gt?: number | null
  value_gte?: number | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: IntTSRestrictedWhereInput[]
}
export type IntTSRestrictedWhereInputInputObject =
  | Extract<keyof IntTSRestrictedWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface TileTSWhereInput {
  value?: TileWhereInput | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: TileTSWhereInput[]
}
export type TileTSWhereInputInputObject =
  | Extract<keyof TileTSWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface TileWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  terrain_some?: IntTSWhereInput | null
  terrain_every?: IntTSRestrictedWhereInput | null
  terrain_none?: IntTSRestrictedWhereInput | null
  feature_some?: IntTSWhereInput | null
  feature_every?: IntTSRestrictedWhereInput | null
  feature_none?: IntTSRestrictedWhereInput | null
  AND?: TileWhereInput[]
}
export type TileWhereInputInputObject =
  | Extract<keyof TileWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'terrain_some', alias?: string  } 
  | { name: 'terrain_every', alias?: string  } 
  | { name: 'terrain_none', alias?: string  } 
  | { name: 'feature_some', alias?: string  } 
  | { name: 'feature_every', alias?: string  } 
  | { name: 'feature_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface TileTSRestrictedWhereInput {
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: TileTSRestrictedWhereInput[]
}
export type TileTSRestrictedWhereInputInputObject =
  | Extract<keyof TileTSRestrictedWhereInput, string>
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface TechWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  type?: number | null
  type_not?: number | null
  type_in?: number[]
  type_not_in?: number[]
  type_lt?: number | null
  type_lte?: number | null
  type_gt?: number | null
  type_gte?: number | null
  progress_some?: FloatTSWhereInput | null
  progress_every?: FloatTSRestrictedWhereInput | null
  progress_none?: FloatTSRestrictedWhereInput | null
  boosted_some?: BooleanTSWhereInput | null
  boosted_every?: BooleanTSRestrictedWhereInput | null
  boosted_none?: BooleanTSRestrictedWhereInput | null
  cost?: number | null
  cost_not?: number | null
  cost_in?: number[]
  cost_not_in?: number[]
  cost_lt?: number | null
  cost_lte?: number | null
  cost_gt?: number | null
  cost_gte?: number | null
  AND?: TechWhereInput[]
}
export type TechWhereInputInputObject =
  | Extract<keyof TechWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'type_not', alias?: string  } 
  | { name: 'type_in', alias?: string  } 
  | { name: 'type_not_in', alias?: string  } 
  | { name: 'type_lt', alias?: string  } 
  | { name: 'type_lte', alias?: string  } 
  | { name: 'type_gt', alias?: string  } 
  | { name: 'type_gte', alias?: string  } 
  | { name: 'progress_some', alias?: string  } 
  | { name: 'progress_every', alias?: string  } 
  | { name: 'progress_none', alias?: string  } 
  | { name: 'boosted_some', alias?: string  } 
  | { name: 'boosted_every', alias?: string  } 
  | { name: 'boosted_none', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'cost_not', alias?: string  } 
  | { name: 'cost_in', alias?: string  } 
  | { name: 'cost_not_in', alias?: string  } 
  | { name: 'cost_lt', alias?: string  } 
  | { name: 'cost_lte', alias?: string  } 
  | { name: 'cost_gt', alias?: string  } 
  | { name: 'cost_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface FloatTSWhereInput {
  value?: number | null
  value_not?: number | null
  value_in?: number[]
  value_not_in?: number[]
  value_lt?: number | null
  value_lte?: number | null
  value_gt?: number | null
  value_gte?: number | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: FloatTSWhereInput[]
}
export type FloatTSWhereInputInputObject =
  | Extract<keyof FloatTSWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface FloatTSRestrictedWhereInput {
  value?: number | null
  value_not?: number | null
  value_in?: number[]
  value_not_in?: number[]
  value_lt?: number | null
  value_lte?: number | null
  value_gt?: number | null
  value_gte?: number | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: FloatTSRestrictedWhereInput[]
}
export type FloatTSRestrictedWhereInputInputObject =
  | Extract<keyof FloatTSRestrictedWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface CivicWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  type?: number | null
  type_not?: number | null
  type_in?: number[]
  type_not_in?: number[]
  type_lt?: number | null
  type_lte?: number | null
  type_gt?: number | null
  type_gte?: number | null
  progress_some?: FloatTSWhereInput | null
  progress_every?: FloatTSRestrictedWhereInput | null
  progress_none?: FloatTSRestrictedWhereInput | null
  boosted_some?: BooleanTSWhereInput | null
  boosted_every?: BooleanTSRestrictedWhereInput | null
  boosted_none?: BooleanTSRestrictedWhereInput | null
  cost?: number | null
  cost_not?: number | null
  cost_in?: number[]
  cost_not_in?: number[]
  cost_lt?: number | null
  cost_lte?: number | null
  cost_gt?: number | null
  cost_gte?: number | null
  AND?: CivicWhereInput[]
}
export type CivicWhereInputInputObject =
  | Extract<keyof CivicWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'type_not', alias?: string  } 
  | { name: 'type_in', alias?: string  } 
  | { name: 'type_not_in', alias?: string  } 
  | { name: 'type_lt', alias?: string  } 
  | { name: 'type_lte', alias?: string  } 
  | { name: 'type_gt', alias?: string  } 
  | { name: 'type_gte', alias?: string  } 
  | { name: 'progress_some', alias?: string  } 
  | { name: 'progress_every', alias?: string  } 
  | { name: 'progress_none', alias?: string  } 
  | { name: 'boosted_some', alias?: string  } 
  | { name: 'boosted_every', alias?: string  } 
  | { name: 'boosted_none', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'cost_not', alias?: string  } 
  | { name: 'cost_in', alias?: string  } 
  | { name: 'cost_not_in', alias?: string  } 
  | { name: 'cost_lt', alias?: string  } 
  | { name: 'cost_lte', alias?: string  } 
  | { name: 'cost_gt', alias?: string  } 
  | { name: 'cost_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface UnitWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  type?: number | null
  type_not?: number | null
  type_in?: number[]
  type_not_in?: number[]
  type_lt?: number | null
  type_lte?: number | null
  type_gt?: number | null
  type_gte?: number | null
  location_some?: TileTSWhereInput | null
  location_every?: TileTSRestrictedWhereInput | null
  location_none?: TileTSRestrictedWhereInput | null
  cost?: number | null
  cost_not?: number | null
  cost_in?: number[]
  cost_not_in?: number[]
  cost_lt?: number | null
  cost_lte?: number | null
  cost_gt?: number | null
  cost_gte?: number | null
  baseMoves?: number | null
  baseMoves_not?: number | null
  baseMoves_in?: number[]
  baseMoves_not_in?: number[]
  baseMoves_lt?: number | null
  baseMoves_lte?: number | null
  baseMoves_gt?: number | null
  baseMoves_gte?: number | null
  combat?: number | null
  combat_not?: number | null
  combat_in?: number[]
  combat_not_in?: number[]
  combat_lt?: number | null
  combat_lte?: number | null
  combat_gt?: number | null
  combat_gte?: number | null
  range?: number | null
  range_not?: number | null
  range_in?: number[]
  range_not_in?: number[]
  range_lt?: number | null
  range_lte?: number | null
  range_gt?: number | null
  range_gte?: number | null
  rangedCombar?: number | null
  rangedCombar_not?: number | null
  rangedCombar_in?: number[]
  rangedCombar_not_in?: number[]
  rangedCombar_lt?: number | null
  rangedCombar_lte?: number | null
  rangedCombar_gt?: number | null
  rangedCombar_gte?: number | null
  bombard?: number | null
  bombard_not?: number | null
  bombard_in?: number[]
  bombard_not_in?: number[]
  bombard_lt?: number | null
  bombard_lte?: number | null
  bombard_gt?: number | null
  bombard_gte?: number | null
  AND?: UnitWhereInput[]
}
export type UnitWhereInputInputObject =
  | Extract<keyof UnitWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'type_not', alias?: string  } 
  | { name: 'type_in', alias?: string  } 
  | { name: 'type_not_in', alias?: string  } 
  | { name: 'type_lt', alias?: string  } 
  | { name: 'type_lte', alias?: string  } 
  | { name: 'type_gt', alias?: string  } 
  | { name: 'type_gte', alias?: string  } 
  | { name: 'location_some', alias?: string  } 
  | { name: 'location_every', alias?: string  } 
  | { name: 'location_none', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'cost_not', alias?: string  } 
  | { name: 'cost_in', alias?: string  } 
  | { name: 'cost_not_in', alias?: string  } 
  | { name: 'cost_lt', alias?: string  } 
  | { name: 'cost_lte', alias?: string  } 
  | { name: 'cost_gt', alias?: string  } 
  | { name: 'cost_gte', alias?: string  } 
  | { name: 'baseMoves', alias?: string  } 
  | { name: 'baseMoves_not', alias?: string  } 
  | { name: 'baseMoves_in', alias?: string  } 
  | { name: 'baseMoves_not_in', alias?: string  } 
  | { name: 'baseMoves_lt', alias?: string  } 
  | { name: 'baseMoves_lte', alias?: string  } 
  | { name: 'baseMoves_gt', alias?: string  } 
  | { name: 'baseMoves_gte', alias?: string  } 
  | { name: 'combat', alias?: string  } 
  | { name: 'combat_not', alias?: string  } 
  | { name: 'combat_in', alias?: string  } 
  | { name: 'combat_not_in', alias?: string  } 
  | { name: 'combat_lt', alias?: string  } 
  | { name: 'combat_lte', alias?: string  } 
  | { name: 'combat_gt', alias?: string  } 
  | { name: 'combat_gte', alias?: string  } 
  | { name: 'range', alias?: string  } 
  | { name: 'range_not', alias?: string  } 
  | { name: 'range_in', alias?: string  } 
  | { name: 'range_not_in', alias?: string  } 
  | { name: 'range_lt', alias?: string  } 
  | { name: 'range_lte', alias?: string  } 
  | { name: 'range_gt', alias?: string  } 
  | { name: 'range_gte', alias?: string  } 
  | { name: 'rangedCombar', alias?: string  } 
  | { name: 'rangedCombar_not', alias?: string  } 
  | { name: 'rangedCombar_in', alias?: string  } 
  | { name: 'rangedCombar_not_in', alias?: string  } 
  | { name: 'rangedCombar_lt', alias?: string  } 
  | { name: 'rangedCombar_lte', alias?: string  } 
  | { name: 'rangedCombar_gt', alias?: string  } 
  | { name: 'rangedCombar_gte', alias?: string  } 
  | { name: 'bombard', alias?: string  } 
  | { name: 'bombard_not', alias?: string  } 
  | { name: 'bombard_in', alias?: string  } 
  | { name: 'bombard_not_in', alias?: string  } 
  | { name: 'bombard_lt', alias?: string  } 
  | { name: 'bombard_lte', alias?: string  } 
  | { name: 'bombard_gt', alias?: string  } 
  | { name: 'bombard_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface GameWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  leaders_some?: LeaderWhereInput | null
  map?: MapWhereInput | null
  AND?: GameWhereInput[]
}
export type GameWhereInputInputObject =
  | Extract<keyof GameWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'leaders_some', alias?: string  } 
  | { name: 'map', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface MapWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  type?: string | null
  type_not?: string | null
  type_in?: string[]
  type_not_in?: string[]
  type_lt?: string | null
  type_lte?: string | null
  type_gt?: string | null
  type_gte?: string | null
  type_contains?: string | null
  type_not_contains?: string | null
  type_starts_with?: string | null
  type_not_starts_with?: string | null
  type_ends_with?: string | null
  type_not_ends_with?: string | null
  tiles_some?: TileWhereInput | null
  AND?: MapWhereInput[]
}
export type MapWhereInputInputObject =
  | Extract<keyof MapWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'type_not', alias?: string  } 
  | { name: 'type_in', alias?: string  } 
  | { name: 'type_not_in', alias?: string  } 
  | { name: 'type_lt', alias?: string  } 
  | { name: 'type_lte', alias?: string  } 
  | { name: 'type_gt', alias?: string  } 
  | { name: 'type_gte', alias?: string  } 
  | { name: 'type_contains', alias?: string  } 
  | { name: 'type_not_contains', alias?: string  } 
  | { name: 'type_starts_with', alias?: string  } 
  | { name: 'type_not_starts_with', alias?: string  } 
  | { name: 'type_ends_with', alias?: string  } 
  | { name: 'type_not_ends_with', alias?: string  } 
  | { name: 'tiles_some', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface LeaderWhereUniqueInput {
  id?: string | null
}
export type LeaderWhereUniqueInputInputObject =
  | Extract<keyof LeaderWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface PlayerWhereUniqueInput {
  id?: string | null
}
export type PlayerWhereUniqueInputInputObject =
  | Extract<keyof PlayerWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface CityWhereUniqueInput {
  id?: string | null
}
export type CityWhereUniqueInputInputObject =
  | Extract<keyof CityWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface UnitWhereUniqueInput {
  id?: string | null
}
export type UnitWhereUniqueInputInputObject =
  | Extract<keyof UnitWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface TechWhereUniqueInput {
  id?: string | null
}
export type TechWhereUniqueInputInputObject =
  | Extract<keyof TechWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface CivicWhereUniqueInput {
  id?: string | null
}
export type CivicWhereUniqueInputInputObject =
  | Extract<keyof CivicWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface MapWhereUniqueInput {
  id?: string | null
}
export type MapWhereUniqueInputInputObject =
  | Extract<keyof MapWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface TileWhereUniqueInput {
  id?: string | null
}
export type TileWhereUniqueInputInputObject =
  | Extract<keyof TileWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface GameCreateInput {
  id?: string | null
  name?: string
  leaders?: LeaderCreateManyInput | null
  map?: MapCreateOneInput
}
export type GameCreateInputInputObject =
  | Extract<keyof GameCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'leaders', alias?: string  } 
  | { name: 'map', alias?: string  } 
  
export interface LeaderCreateManyInput {
  create?: LeaderCreateInput[]
  connect?: LeaderWhereUniqueInput[]
}
export type LeaderCreateManyInputInputObject =
  | Extract<keyof LeaderCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface LeaderCreateInput {
  id?: string | null
  name?: string
  player?: PlayerCreateOneInput
  cities?: CityCreateManyInput | null
  techs?: TechCreateManyInput | null
  civics?: CivicCreateManyInput | null
  units?: UnitCreateManyInput | null
}
export type LeaderCreateInputInputObject =
  | Extract<keyof LeaderCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'player', alias?: string  } 
  | { name: 'cities', alias?: string  } 
  | { name: 'techs', alias?: string  } 
  | { name: 'civics', alias?: string  } 
  | { name: 'units', alias?: string  } 
  
export interface PlayerCreateOneInput {
  create?: PlayerCreateInput | null
  connect?: PlayerWhereUniqueInput | null
}
export type PlayerCreateOneInputInputObject =
  | Extract<keyof PlayerCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface PlayerCreateInput {
  id?: string | null
  name?: StringTSCreateManyInput | null
  isHuman?: BooleanTSCreateManyInput | null
}
export type PlayerCreateInputInputObject =
  | Extract<keyof PlayerCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isHuman', alias?: string  } 
  
export interface StringTSCreateManyInput {
  create?: StringTSCreateInput[]
}
export type StringTSCreateManyInputInputObject =
  | Extract<keyof StringTSCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  
export interface StringTSCreateInput {
  value?: string
}
export type StringTSCreateInputInputObject =
  | Extract<keyof StringTSCreateInput, string>
  | { name: 'value', alias?: string  } 
  
export interface BooleanTSCreateManyInput {
  create?: BooleanTSCreateInput[]
}
export type BooleanTSCreateManyInputInputObject =
  | Extract<keyof BooleanTSCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  
export interface BooleanTSCreateInput {
  value?: boolean
}
export type BooleanTSCreateInputInputObject =
  | Extract<keyof BooleanTSCreateInput, string>
  | { name: 'value', alias?: string  } 
  
export interface CityCreateManyInput {
  create?: CityCreateInput[]
  connect?: CityWhereUniqueInput[]
}
export type CityCreateManyInputInputObject =
  | Extract<keyof CityCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface CityCreateInput {
  id?: string | null
  name?: StringTSCreateManyInput | null
  isExist?: BooleanTSCreateManyInput | null
  population?: IntTSCreateManyInput | null
  amenity?: IntTSCreateManyInput | null
  entertainment?: IntTSCreateManyInput | null
  location?: TileTSCreateManyInput | null
}
export type CityCreateInputInputObject =
  | Extract<keyof CityCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isExist', alias?: string  } 
  | { name: 'population', alias?: string  } 
  | { name: 'amenity', alias?: string  } 
  | { name: 'entertainment', alias?: string  } 
  | { name: 'location', alias?: string  } 
  
export interface IntTSCreateManyInput {
  create?: IntTSCreateInput[]
}
export type IntTSCreateManyInputInputObject =
  | Extract<keyof IntTSCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  
export interface IntTSCreateInput {
  value?: number
}
export type IntTSCreateInputInputObject =
  | Extract<keyof IntTSCreateInput, string>
  | { name: 'value', alias?: string  } 
  
export interface TileTSCreateManyInput {
  create?: TileTSCreateInput[]
}
export type TileTSCreateManyInputInputObject =
  | Extract<keyof TileTSCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  
export interface TileTSCreateInput {
  value?: TileCreateOneInput
}
export type TileTSCreateInputInputObject =
  | Extract<keyof TileTSCreateInput, string>
  | { name: 'value', alias?: string  } 
  
export interface TileCreateOneInput {
  create?: TileCreateInput | null
  connect?: TileWhereUniqueInput | null
}
export type TileCreateOneInputInputObject =
  | Extract<keyof TileCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TileCreateInput {
  id?: string | null
  location?: TileCreatelocationInput | null
  terrain?: IntTSCreateManyInput | null
  feature?: IntTSCreateManyInput | null
}
export type TileCreateInputInputObject =
  | Extract<keyof TileCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'location', alias?: string  } 
  | { name: 'terrain', alias?: string  } 
  | { name: 'feature', alias?: string  } 
  
export interface TileCreatelocationInput {
  set?: number[]
}
export type TileCreatelocationInputInputObject =
  | Extract<keyof TileCreatelocationInput, string>
  | { name: 'set', alias?: string  } 
  
export interface TechCreateManyInput {
  create?: TechCreateInput[]
  connect?: TechWhereUniqueInput[]
}
export type TechCreateManyInputInputObject =
  | Extract<keyof TechCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TechCreateInput {
  id?: string | null
  type?: number
  progress?: FloatTSCreateManyInput | null
  boosted?: BooleanTSCreateManyInput | null
  cost?: number
}
export type TechCreateInputInputObject =
  | Extract<keyof TechCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'progress', alias?: string  } 
  | { name: 'boosted', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface FloatTSCreateManyInput {
  create?: FloatTSCreateInput[]
}
export type FloatTSCreateManyInputInputObject =
  | Extract<keyof FloatTSCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  
export interface FloatTSCreateInput {
  value?: number
}
export type FloatTSCreateInputInputObject =
  | Extract<keyof FloatTSCreateInput, string>
  | { name: 'value', alias?: string  } 
  
export interface CivicCreateManyInput {
  create?: CivicCreateInput[]
  connect?: CivicWhereUniqueInput[]
}
export type CivicCreateManyInputInputObject =
  | Extract<keyof CivicCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface CivicCreateInput {
  id?: string | null
  type?: number
  progress?: FloatTSCreateManyInput | null
  boosted?: BooleanTSCreateManyInput | null
  cost?: number
}
export type CivicCreateInputInputObject =
  | Extract<keyof CivicCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'progress', alias?: string  } 
  | { name: 'boosted', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface UnitCreateManyInput {
  create?: UnitCreateInput[]
  connect?: UnitWhereUniqueInput[]
}
export type UnitCreateManyInputInputObject =
  | Extract<keyof UnitCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UnitCreateInput {
  id?: string | null
  type?: number
  location?: TileTSCreateManyInput | null
  cost?: number
  baseMoves?: number | null
  combat?: number | null
  range?: number | null
  rangedCombar?: number | null
  bombard?: number | null
}
export type UnitCreateInputInputObject =
  | Extract<keyof UnitCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'location', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'baseMoves', alias?: string  } 
  | { name: 'combat', alias?: string  } 
  | { name: 'range', alias?: string  } 
  | { name: 'rangedCombar', alias?: string  } 
  | { name: 'bombard', alias?: string  } 
  
export interface MapCreateOneInput {
  create?: MapCreateInput | null
  connect?: MapWhereUniqueInput | null
}
export type MapCreateOneInputInputObject =
  | Extract<keyof MapCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface MapCreateInput {
  id?: string | null
  type?: string
  tiles?: TileCreateManyInput | null
}
export type MapCreateInputInputObject =
  | Extract<keyof MapCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'tiles', alias?: string  } 
  
export interface TileCreateManyInput {
  create?: TileCreateInput[]
  connect?: TileWhereUniqueInput[]
}
export type TileCreateManyInputInputObject =
  | Extract<keyof TileCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface GameUpdateInput {
  name?: string | null
  leaders?: LeaderUpdateManyInput | null
  map?: MapUpdateOneRequiredInput | null
}
export type GameUpdateInputInputObject =
  | Extract<keyof GameUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'leaders', alias?: string  } 
  | { name: 'map', alias?: string  } 
  
export interface LeaderUpdateManyInput {
  create?: LeaderCreateInput[]
  update?: LeaderUpdateWithWhereUniqueNestedInput[]
  upsert?: LeaderUpsertWithWhereUniqueNestedInput[]
  delete?: LeaderWhereUniqueInput[]
  connect?: LeaderWhereUniqueInput[]
  set?: LeaderWhereUniqueInput[]
  disconnect?: LeaderWhereUniqueInput[]
  deleteMany?: LeaderScalarWhereInput[]
  updateMany?: LeaderUpdateManyWithWhereNestedInput[]
}
export type LeaderUpdateManyInputInputObject =
  | Extract<keyof LeaderUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface LeaderUpdateWithWhereUniqueNestedInput {
  where?: LeaderWhereUniqueInput
  data?: LeaderUpdateDataInput
}
export type LeaderUpdateWithWhereUniqueNestedInputInputObject =
  | Extract<keyof LeaderUpdateWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface LeaderUpdateDataInput {
  name?: string | null
  player?: PlayerUpdateOneRequiredInput | null
  cities?: CityUpdateManyInput | null
  techs?: TechUpdateManyInput | null
  civics?: CivicUpdateManyInput | null
  units?: UnitUpdateManyInput | null
}
export type LeaderUpdateDataInputInputObject =
  | Extract<keyof LeaderUpdateDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'player', alias?: string  } 
  | { name: 'cities', alias?: string  } 
  | { name: 'techs', alias?: string  } 
  | { name: 'civics', alias?: string  } 
  | { name: 'units', alias?: string  } 
  
export interface PlayerUpdateOneRequiredInput {
  create?: PlayerCreateInput | null
  update?: PlayerUpdateDataInput | null
  upsert?: PlayerUpsertNestedInput | null
  connect?: PlayerWhereUniqueInput | null
}
export type PlayerUpdateOneRequiredInputInputObject =
  | Extract<keyof PlayerUpdateOneRequiredInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface PlayerUpdateDataInput {
  name?: StringTSUpdateManyInput | null
  isHuman?: BooleanTSUpdateManyInput | null
}
export type PlayerUpdateDataInputInputObject =
  | Extract<keyof PlayerUpdateDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'isHuman', alias?: string  } 
  
export interface StringTSUpdateManyInput {
  create?: StringTSCreateInput[]
  deleteMany?: StringTSScalarWhereInput[]
  updateMany?: StringTSUpdateManyWithWhereNestedInput[]
}
export type StringTSUpdateManyInputInputObject =
  | Extract<keyof StringTSUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface StringTSScalarWhereInput {
  value?: string | null
  value_not?: string | null
  value_in?: string[]
  value_not_in?: string[]
  value_lt?: string | null
  value_lte?: string | null
  value_gt?: string | null
  value_gte?: string | null
  value_contains?: string | null
  value_not_contains?: string | null
  value_starts_with?: string | null
  value_not_starts_with?: string | null
  value_ends_with?: string | null
  value_not_ends_with?: string | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: StringTSScalarWhereInput[]
  OR?: StringTSScalarWhereInput[]
  NOT?: StringTSScalarWhereInput[]
}
export type StringTSScalarWhereInputInputObject =
  | Extract<keyof StringTSScalarWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'value_contains', alias?: string  } 
  | { name: 'value_not_contains', alias?: string  } 
  | { name: 'value_starts_with', alias?: string  } 
  | { name: 'value_not_starts_with', alias?: string  } 
  | { name: 'value_ends_with', alias?: string  } 
  | { name: 'value_not_ends_with', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface StringTSUpdateManyWithWhereNestedInput {
  where?: StringTSScalarWhereInput
  data?: StringTSUpdateManyDataInput
}
export type StringTSUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof StringTSUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface StringTSUpdateManyDataInput {
  value?: string | null
}
export type StringTSUpdateManyDataInputInputObject =
  | Extract<keyof StringTSUpdateManyDataInput, string>
  | { name: 'value', alias?: string  } 
  
export interface BooleanTSUpdateManyInput {
  create?: BooleanTSCreateInput[]
  deleteMany?: BooleanTSScalarWhereInput[]
  updateMany?: BooleanTSUpdateManyWithWhereNestedInput[]
}
export type BooleanTSUpdateManyInputInputObject =
  | Extract<keyof BooleanTSUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface BooleanTSScalarWhereInput {
  value?: boolean | null
  value_not?: boolean | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: BooleanTSScalarWhereInput[]
  OR?: BooleanTSScalarWhereInput[]
  NOT?: BooleanTSScalarWhereInput[]
}
export type BooleanTSScalarWhereInputInputObject =
  | Extract<keyof BooleanTSScalarWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface BooleanTSUpdateManyWithWhereNestedInput {
  where?: BooleanTSScalarWhereInput
  data?: BooleanTSUpdateManyDataInput
}
export type BooleanTSUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof BooleanTSUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface BooleanTSUpdateManyDataInput {
  value?: boolean | null
}
export type BooleanTSUpdateManyDataInputInputObject =
  | Extract<keyof BooleanTSUpdateManyDataInput, string>
  | { name: 'value', alias?: string  } 
  
export interface PlayerUpsertNestedInput {
  update?: PlayerUpdateDataInput
  create?: PlayerCreateInput
}
export type PlayerUpsertNestedInputInputObject =
  | Extract<keyof PlayerUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CityUpdateManyInput {
  create?: CityCreateInput[]
  update?: CityUpdateWithWhereUniqueNestedInput[]
  upsert?: CityUpsertWithWhereUniqueNestedInput[]
  delete?: CityWhereUniqueInput[]
  connect?: CityWhereUniqueInput[]
  set?: CityWhereUniqueInput[]
  disconnect?: CityWhereUniqueInput[]
  deleteMany?: CityScalarWhereInput[]
}
export type CityUpdateManyInputInputObject =
  | Extract<keyof CityUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  
export interface CityUpdateWithWhereUniqueNestedInput {
  where?: CityWhereUniqueInput
  data?: CityUpdateDataInput
}
export type CityUpdateWithWhereUniqueNestedInputInputObject =
  | Extract<keyof CityUpdateWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface CityUpdateDataInput {
  name?: StringTSUpdateManyInput | null
  isExist?: BooleanTSUpdateManyInput | null
  population?: IntTSUpdateManyInput | null
  amenity?: IntTSUpdateManyInput | null
  entertainment?: IntTSUpdateManyInput | null
  location?: TileTSUpdateManyInput | null
}
export type CityUpdateDataInputInputObject =
  | Extract<keyof CityUpdateDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'isExist', alias?: string  } 
  | { name: 'population', alias?: string  } 
  | { name: 'amenity', alias?: string  } 
  | { name: 'entertainment', alias?: string  } 
  | { name: 'location', alias?: string  } 
  
export interface IntTSUpdateManyInput {
  create?: IntTSCreateInput[]
  deleteMany?: IntTSScalarWhereInput[]
  updateMany?: IntTSUpdateManyWithWhereNestedInput[]
}
export type IntTSUpdateManyInputInputObject =
  | Extract<keyof IntTSUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface IntTSScalarWhereInput {
  value?: number | null
  value_not?: number | null
  value_in?: number[]
  value_not_in?: number[]
  value_lt?: number | null
  value_lte?: number | null
  value_gt?: number | null
  value_gte?: number | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: IntTSScalarWhereInput[]
  OR?: IntTSScalarWhereInput[]
  NOT?: IntTSScalarWhereInput[]
}
export type IntTSScalarWhereInputInputObject =
  | Extract<keyof IntTSScalarWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface IntTSUpdateManyWithWhereNestedInput {
  where?: IntTSScalarWhereInput
  data?: IntTSUpdateManyDataInput
}
export type IntTSUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof IntTSUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface IntTSUpdateManyDataInput {
  value?: number | null
}
export type IntTSUpdateManyDataInputInputObject =
  | Extract<keyof IntTSUpdateManyDataInput, string>
  | { name: 'value', alias?: string  } 
  
export interface TileTSUpdateManyInput {
  create?: TileTSCreateInput[]
  deleteMany?: TileTSScalarWhereInput[]
}
export type TileTSUpdateManyInputInputObject =
  | Extract<keyof TileTSUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  
export interface TileTSScalarWhereInput {
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: TileTSScalarWhereInput[]
  OR?: TileTSScalarWhereInput[]
  NOT?: TileTSScalarWhereInput[]
}
export type TileTSScalarWhereInputInputObject =
  | Extract<keyof TileTSScalarWhereInput, string>
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CityUpsertWithWhereUniqueNestedInput {
  where?: CityWhereUniqueInput
  update?: CityUpdateDataInput
  create?: CityCreateInput
}
export type CityUpsertWithWhereUniqueNestedInputInputObject =
  | Extract<keyof CityUpsertWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CityScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  AND?: CityScalarWhereInput[]
  OR?: CityScalarWhereInput[]
  NOT?: CityScalarWhereInput[]
}
export type CityScalarWhereInputInputObject =
  | Extract<keyof CityScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TechUpdateManyInput {
  create?: TechCreateInput[]
  update?: TechUpdateWithWhereUniqueNestedInput[]
  upsert?: TechUpsertWithWhereUniqueNestedInput[]
  delete?: TechWhereUniqueInput[]
  connect?: TechWhereUniqueInput[]
  set?: TechWhereUniqueInput[]
  disconnect?: TechWhereUniqueInput[]
  deleteMany?: TechScalarWhereInput[]
  updateMany?: TechUpdateManyWithWhereNestedInput[]
}
export type TechUpdateManyInputInputObject =
  | Extract<keyof TechUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface TechUpdateWithWhereUniqueNestedInput {
  where?: TechWhereUniqueInput
  data?: TechUpdateDataInput
}
export type TechUpdateWithWhereUniqueNestedInputInputObject =
  | Extract<keyof TechUpdateWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TechUpdateDataInput {
  type?: number | null
  progress?: FloatTSUpdateManyInput | null
  boosted?: BooleanTSUpdateManyInput | null
  cost?: number | null
}
export type TechUpdateDataInputInputObject =
  | Extract<keyof TechUpdateDataInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'progress', alias?: string  } 
  | { name: 'boosted', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface FloatTSUpdateManyInput {
  create?: FloatTSCreateInput[]
  deleteMany?: FloatTSScalarWhereInput[]
  updateMany?: FloatTSUpdateManyWithWhereNestedInput[]
}
export type FloatTSUpdateManyInputInputObject =
  | Extract<keyof FloatTSUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface FloatTSScalarWhereInput {
  value?: number | null
  value_not?: number | null
  value_in?: number[]
  value_not_in?: number[]
  value_lt?: number | null
  value_lte?: number | null
  value_gt?: number | null
  value_gte?: number | null
  time?: string | null
  time_not?: string | null
  time_in?: string[]
  time_not_in?: string[]
  time_lt?: string | null
  time_lte?: string | null
  time_gt?: string | null
  time_gte?: string | null
  AND?: FloatTSScalarWhereInput[]
  OR?: FloatTSScalarWhereInput[]
  NOT?: FloatTSScalarWhereInput[]
}
export type FloatTSScalarWhereInputInputObject =
  | Extract<keyof FloatTSScalarWhereInput, string>
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'time', alias?: string  } 
  | { name: 'time_not', alias?: string  } 
  | { name: 'time_in', alias?: string  } 
  | { name: 'time_not_in', alias?: string  } 
  | { name: 'time_lt', alias?: string  } 
  | { name: 'time_lte', alias?: string  } 
  | { name: 'time_gt', alias?: string  } 
  | { name: 'time_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface FloatTSUpdateManyWithWhereNestedInput {
  where?: FloatTSScalarWhereInput
  data?: FloatTSUpdateManyDataInput
}
export type FloatTSUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof FloatTSUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface FloatTSUpdateManyDataInput {
  value?: number | null
}
export type FloatTSUpdateManyDataInputInputObject =
  | Extract<keyof FloatTSUpdateManyDataInput, string>
  | { name: 'value', alias?: string  } 
  
export interface TechUpsertWithWhereUniqueNestedInput {
  where?: TechWhereUniqueInput
  update?: TechUpdateDataInput
  create?: TechCreateInput
}
export type TechUpsertWithWhereUniqueNestedInputInputObject =
  | Extract<keyof TechUpsertWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TechScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  type?: number | null
  type_not?: number | null
  type_in?: number[]
  type_not_in?: number[]
  type_lt?: number | null
  type_lte?: number | null
  type_gt?: number | null
  type_gte?: number | null
  cost?: number | null
  cost_not?: number | null
  cost_in?: number[]
  cost_not_in?: number[]
  cost_lt?: number | null
  cost_lte?: number | null
  cost_gt?: number | null
  cost_gte?: number | null
  AND?: TechScalarWhereInput[]
  OR?: TechScalarWhereInput[]
  NOT?: TechScalarWhereInput[]
}
export type TechScalarWhereInputInputObject =
  | Extract<keyof TechScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'type_not', alias?: string  } 
  | { name: 'type_in', alias?: string  } 
  | { name: 'type_not_in', alias?: string  } 
  | { name: 'type_lt', alias?: string  } 
  | { name: 'type_lte', alias?: string  } 
  | { name: 'type_gt', alias?: string  } 
  | { name: 'type_gte', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'cost_not', alias?: string  } 
  | { name: 'cost_in', alias?: string  } 
  | { name: 'cost_not_in', alias?: string  } 
  | { name: 'cost_lt', alias?: string  } 
  | { name: 'cost_lte', alias?: string  } 
  | { name: 'cost_gt', alias?: string  } 
  | { name: 'cost_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TechUpdateManyWithWhereNestedInput {
  where?: TechScalarWhereInput
  data?: TechUpdateManyDataInput
}
export type TechUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof TechUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TechUpdateManyDataInput {
  type?: number | null
  cost?: number | null
}
export type TechUpdateManyDataInputInputObject =
  | Extract<keyof TechUpdateManyDataInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface CivicUpdateManyInput {
  create?: CivicCreateInput[]
  update?: CivicUpdateWithWhereUniqueNestedInput[]
  upsert?: CivicUpsertWithWhereUniqueNestedInput[]
  delete?: CivicWhereUniqueInput[]
  connect?: CivicWhereUniqueInput[]
  set?: CivicWhereUniqueInput[]
  disconnect?: CivicWhereUniqueInput[]
  deleteMany?: CivicScalarWhereInput[]
  updateMany?: CivicUpdateManyWithWhereNestedInput[]
}
export type CivicUpdateManyInputInputObject =
  | Extract<keyof CivicUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface CivicUpdateWithWhereUniqueNestedInput {
  where?: CivicWhereUniqueInput
  data?: CivicUpdateDataInput
}
export type CivicUpdateWithWhereUniqueNestedInputInputObject =
  | Extract<keyof CivicUpdateWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface CivicUpdateDataInput {
  type?: number | null
  progress?: FloatTSUpdateManyInput | null
  boosted?: BooleanTSUpdateManyInput | null
  cost?: number | null
}
export type CivicUpdateDataInputInputObject =
  | Extract<keyof CivicUpdateDataInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'progress', alias?: string  } 
  | { name: 'boosted', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface CivicUpsertWithWhereUniqueNestedInput {
  where?: CivicWhereUniqueInput
  update?: CivicUpdateDataInput
  create?: CivicCreateInput
}
export type CivicUpsertWithWhereUniqueNestedInputInputObject =
  | Extract<keyof CivicUpsertWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CivicScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  type?: number | null
  type_not?: number | null
  type_in?: number[]
  type_not_in?: number[]
  type_lt?: number | null
  type_lte?: number | null
  type_gt?: number | null
  type_gte?: number | null
  cost?: number | null
  cost_not?: number | null
  cost_in?: number[]
  cost_not_in?: number[]
  cost_lt?: number | null
  cost_lte?: number | null
  cost_gt?: number | null
  cost_gte?: number | null
  AND?: CivicScalarWhereInput[]
  OR?: CivicScalarWhereInput[]
  NOT?: CivicScalarWhereInput[]
}
export type CivicScalarWhereInputInputObject =
  | Extract<keyof CivicScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'type_not', alias?: string  } 
  | { name: 'type_in', alias?: string  } 
  | { name: 'type_not_in', alias?: string  } 
  | { name: 'type_lt', alias?: string  } 
  | { name: 'type_lte', alias?: string  } 
  | { name: 'type_gt', alias?: string  } 
  | { name: 'type_gte', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'cost_not', alias?: string  } 
  | { name: 'cost_in', alias?: string  } 
  | { name: 'cost_not_in', alias?: string  } 
  | { name: 'cost_lt', alias?: string  } 
  | { name: 'cost_lte', alias?: string  } 
  | { name: 'cost_gt', alias?: string  } 
  | { name: 'cost_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CivicUpdateManyWithWhereNestedInput {
  where?: CivicScalarWhereInput
  data?: CivicUpdateManyDataInput
}
export type CivicUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof CivicUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface CivicUpdateManyDataInput {
  type?: number | null
  cost?: number | null
}
export type CivicUpdateManyDataInputInputObject =
  | Extract<keyof CivicUpdateManyDataInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface UnitUpdateManyInput {
  create?: UnitCreateInput[]
  update?: UnitUpdateWithWhereUniqueNestedInput[]
  upsert?: UnitUpsertWithWhereUniqueNestedInput[]
  delete?: UnitWhereUniqueInput[]
  connect?: UnitWhereUniqueInput[]
  set?: UnitWhereUniqueInput[]
  disconnect?: UnitWhereUniqueInput[]
  deleteMany?: UnitScalarWhereInput[]
  updateMany?: UnitUpdateManyWithWhereNestedInput[]
}
export type UnitUpdateManyInputInputObject =
  | Extract<keyof UnitUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface UnitUpdateWithWhereUniqueNestedInput {
  where?: UnitWhereUniqueInput
  data?: UnitUpdateDataInput
}
export type UnitUpdateWithWhereUniqueNestedInputInputObject =
  | Extract<keyof UnitUpdateWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface UnitUpdateDataInput {
  type?: number | null
  location?: TileTSUpdateManyInput | null
  cost?: number | null
  baseMoves?: number | null
  combat?: number | null
  range?: number | null
  rangedCombar?: number | null
  bombard?: number | null
}
export type UnitUpdateDataInputInputObject =
  | Extract<keyof UnitUpdateDataInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'location', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'baseMoves', alias?: string  } 
  | { name: 'combat', alias?: string  } 
  | { name: 'range', alias?: string  } 
  | { name: 'rangedCombar', alias?: string  } 
  | { name: 'bombard', alias?: string  } 
  
export interface UnitUpsertWithWhereUniqueNestedInput {
  where?: UnitWhereUniqueInput
  update?: UnitUpdateDataInput
  create?: UnitCreateInput
}
export type UnitUpsertWithWhereUniqueNestedInputInputObject =
  | Extract<keyof UnitUpsertWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface UnitScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  type?: number | null
  type_not?: number | null
  type_in?: number[]
  type_not_in?: number[]
  type_lt?: number | null
  type_lte?: number | null
  type_gt?: number | null
  type_gte?: number | null
  cost?: number | null
  cost_not?: number | null
  cost_in?: number[]
  cost_not_in?: number[]
  cost_lt?: number | null
  cost_lte?: number | null
  cost_gt?: number | null
  cost_gte?: number | null
  baseMoves?: number | null
  baseMoves_not?: number | null
  baseMoves_in?: number[]
  baseMoves_not_in?: number[]
  baseMoves_lt?: number | null
  baseMoves_lte?: number | null
  baseMoves_gt?: number | null
  baseMoves_gte?: number | null
  combat?: number | null
  combat_not?: number | null
  combat_in?: number[]
  combat_not_in?: number[]
  combat_lt?: number | null
  combat_lte?: number | null
  combat_gt?: number | null
  combat_gte?: number | null
  range?: number | null
  range_not?: number | null
  range_in?: number[]
  range_not_in?: number[]
  range_lt?: number | null
  range_lte?: number | null
  range_gt?: number | null
  range_gte?: number | null
  rangedCombar?: number | null
  rangedCombar_not?: number | null
  rangedCombar_in?: number[]
  rangedCombar_not_in?: number[]
  rangedCombar_lt?: number | null
  rangedCombar_lte?: number | null
  rangedCombar_gt?: number | null
  rangedCombar_gte?: number | null
  bombard?: number | null
  bombard_not?: number | null
  bombard_in?: number[]
  bombard_not_in?: number[]
  bombard_lt?: number | null
  bombard_lte?: number | null
  bombard_gt?: number | null
  bombard_gte?: number | null
  AND?: UnitScalarWhereInput[]
  OR?: UnitScalarWhereInput[]
  NOT?: UnitScalarWhereInput[]
}
export type UnitScalarWhereInputInputObject =
  | Extract<keyof UnitScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'type', alias?: string  } 
  | { name: 'type_not', alias?: string  } 
  | { name: 'type_in', alias?: string  } 
  | { name: 'type_not_in', alias?: string  } 
  | { name: 'type_lt', alias?: string  } 
  | { name: 'type_lte', alias?: string  } 
  | { name: 'type_gt', alias?: string  } 
  | { name: 'type_gte', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'cost_not', alias?: string  } 
  | { name: 'cost_in', alias?: string  } 
  | { name: 'cost_not_in', alias?: string  } 
  | { name: 'cost_lt', alias?: string  } 
  | { name: 'cost_lte', alias?: string  } 
  | { name: 'cost_gt', alias?: string  } 
  | { name: 'cost_gte', alias?: string  } 
  | { name: 'baseMoves', alias?: string  } 
  | { name: 'baseMoves_not', alias?: string  } 
  | { name: 'baseMoves_in', alias?: string  } 
  | { name: 'baseMoves_not_in', alias?: string  } 
  | { name: 'baseMoves_lt', alias?: string  } 
  | { name: 'baseMoves_lte', alias?: string  } 
  | { name: 'baseMoves_gt', alias?: string  } 
  | { name: 'baseMoves_gte', alias?: string  } 
  | { name: 'combat', alias?: string  } 
  | { name: 'combat_not', alias?: string  } 
  | { name: 'combat_in', alias?: string  } 
  | { name: 'combat_not_in', alias?: string  } 
  | { name: 'combat_lt', alias?: string  } 
  | { name: 'combat_lte', alias?: string  } 
  | { name: 'combat_gt', alias?: string  } 
  | { name: 'combat_gte', alias?: string  } 
  | { name: 'range', alias?: string  } 
  | { name: 'range_not', alias?: string  } 
  | { name: 'range_in', alias?: string  } 
  | { name: 'range_not_in', alias?: string  } 
  | { name: 'range_lt', alias?: string  } 
  | { name: 'range_lte', alias?: string  } 
  | { name: 'range_gt', alias?: string  } 
  | { name: 'range_gte', alias?: string  } 
  | { name: 'rangedCombar', alias?: string  } 
  | { name: 'rangedCombar_not', alias?: string  } 
  | { name: 'rangedCombar_in', alias?: string  } 
  | { name: 'rangedCombar_not_in', alias?: string  } 
  | { name: 'rangedCombar_lt', alias?: string  } 
  | { name: 'rangedCombar_lte', alias?: string  } 
  | { name: 'rangedCombar_gt', alias?: string  } 
  | { name: 'rangedCombar_gte', alias?: string  } 
  | { name: 'bombard', alias?: string  } 
  | { name: 'bombard_not', alias?: string  } 
  | { name: 'bombard_in', alias?: string  } 
  | { name: 'bombard_not_in', alias?: string  } 
  | { name: 'bombard_lt', alias?: string  } 
  | { name: 'bombard_lte', alias?: string  } 
  | { name: 'bombard_gt', alias?: string  } 
  | { name: 'bombard_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface UnitUpdateManyWithWhereNestedInput {
  where?: UnitScalarWhereInput
  data?: UnitUpdateManyDataInput
}
export type UnitUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof UnitUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface UnitUpdateManyDataInput {
  type?: number | null
  cost?: number | null
  baseMoves?: number | null
  combat?: number | null
  range?: number | null
  rangedCombar?: number | null
  bombard?: number | null
}
export type UnitUpdateManyDataInputInputObject =
  | Extract<keyof UnitUpdateManyDataInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'baseMoves', alias?: string  } 
  | { name: 'combat', alias?: string  } 
  | { name: 'range', alias?: string  } 
  | { name: 'rangedCombar', alias?: string  } 
  | { name: 'bombard', alias?: string  } 
  
export interface LeaderUpsertWithWhereUniqueNestedInput {
  where?: LeaderWhereUniqueInput
  update?: LeaderUpdateDataInput
  create?: LeaderCreateInput
}
export type LeaderUpsertWithWhereUniqueNestedInputInputObject =
  | Extract<keyof LeaderUpsertWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface LeaderScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  AND?: LeaderScalarWhereInput[]
  OR?: LeaderScalarWhereInput[]
  NOT?: LeaderScalarWhereInput[]
}
export type LeaderScalarWhereInputInputObject =
  | Extract<keyof LeaderScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface LeaderUpdateManyWithWhereNestedInput {
  where?: LeaderScalarWhereInput
  data?: LeaderUpdateManyDataInput
}
export type LeaderUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof LeaderUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface LeaderUpdateManyDataInput {
  name?: string | null
}
export type LeaderUpdateManyDataInputInputObject =
  | Extract<keyof LeaderUpdateManyDataInput, string>
  | { name: 'name', alias?: string  } 
  
export interface MapUpdateOneRequiredInput {
  create?: MapCreateInput | null
  update?: MapUpdateDataInput | null
  upsert?: MapUpsertNestedInput | null
  connect?: MapWhereUniqueInput | null
}
export type MapUpdateOneRequiredInputInputObject =
  | Extract<keyof MapUpdateOneRequiredInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface MapUpdateDataInput {
  type?: string | null
  tiles?: TileUpdateManyInput | null
}
export type MapUpdateDataInputInputObject =
  | Extract<keyof MapUpdateDataInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'tiles', alias?: string  } 
  
export interface TileUpdateManyInput {
  create?: TileCreateInput[]
  update?: TileUpdateWithWhereUniqueNestedInput[]
  upsert?: TileUpsertWithWhereUniqueNestedInput[]
  delete?: TileWhereUniqueInput[]
  connect?: TileWhereUniqueInput[]
  set?: TileWhereUniqueInput[]
  disconnect?: TileWhereUniqueInput[]
  deleteMany?: TileScalarWhereInput[]
  updateMany?: TileUpdateManyWithWhereNestedInput[]
}
export type TileUpdateManyInputInputObject =
  | Extract<keyof TileUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface TileUpdateWithWhereUniqueNestedInput {
  where?: TileWhereUniqueInput
  data?: TileUpdateDataInput
}
export type TileUpdateWithWhereUniqueNestedInputInputObject =
  | Extract<keyof TileUpdateWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TileUpdateDataInput {
  location?: TileUpdatelocationInput | null
  terrain?: IntTSUpdateManyInput | null
  feature?: IntTSUpdateManyInput | null
}
export type TileUpdateDataInputInputObject =
  | Extract<keyof TileUpdateDataInput, string>
  | { name: 'location', alias?: string  } 
  | { name: 'terrain', alias?: string  } 
  | { name: 'feature', alias?: string  } 
  
export interface TileUpdatelocationInput {
  set?: number[]
}
export type TileUpdatelocationInputInputObject =
  | Extract<keyof TileUpdatelocationInput, string>
  | { name: 'set', alias?: string  } 
  
export interface TileUpsertWithWhereUniqueNestedInput {
  where?: TileWhereUniqueInput
  update?: TileUpdateDataInput
  create?: TileCreateInput
}
export type TileUpsertWithWhereUniqueNestedInputInputObject =
  | Extract<keyof TileUpsertWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TileScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  AND?: TileScalarWhereInput[]
  OR?: TileScalarWhereInput[]
  NOT?: TileScalarWhereInput[]
}
export type TileScalarWhereInputInputObject =
  | Extract<keyof TileScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TileUpdateManyWithWhereNestedInput {
  where?: TileScalarWhereInput
  data?: TileUpdateManyDataInput
}
export type TileUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof TileUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TileUpdateManyDataInput {
  location?: TileUpdatelocationInput | null
}
export type TileUpdateManyDataInputInputObject =
  | Extract<keyof TileUpdateManyDataInput, string>
  | { name: 'location', alias?: string  } 
  
export interface MapUpsertNestedInput {
  update?: MapUpdateDataInput
  create?: MapCreateInput
}
export type MapUpsertNestedInputInputObject =
  | Extract<keyof MapUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface GameUpdateManyMutationInput {
  name?: string | null
}
export type GameUpdateManyMutationInputInputObject =
  | Extract<keyof GameUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  
export interface LeaderUpdateInput {
  name?: string | null
  player?: PlayerUpdateOneRequiredInput | null
  cities?: CityUpdateManyInput | null
  techs?: TechUpdateManyInput | null
  civics?: CivicUpdateManyInput | null
  units?: UnitUpdateManyInput | null
}
export type LeaderUpdateInputInputObject =
  | Extract<keyof LeaderUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'player', alias?: string  } 
  | { name: 'cities', alias?: string  } 
  | { name: 'techs', alias?: string  } 
  | { name: 'civics', alias?: string  } 
  | { name: 'units', alias?: string  } 
  
export interface LeaderUpdateManyMutationInput {
  name?: string | null
}
export type LeaderUpdateManyMutationInputInputObject =
  | Extract<keyof LeaderUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  
export interface PlayerUpdateInput {
  name?: StringTSUpdateManyInput | null
  isHuman?: BooleanTSUpdateManyInput | null
}
export type PlayerUpdateInputInputObject =
  | Extract<keyof PlayerUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'isHuman', alias?: string  } 
  
export interface CityUpdateInput {
  name?: StringTSUpdateManyInput | null
  isExist?: BooleanTSUpdateManyInput | null
  population?: IntTSUpdateManyInput | null
  amenity?: IntTSUpdateManyInput | null
  entertainment?: IntTSUpdateManyInput | null
  location?: TileTSUpdateManyInput | null
}
export type CityUpdateInputInputObject =
  | Extract<keyof CityUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'isExist', alias?: string  } 
  | { name: 'population', alias?: string  } 
  | { name: 'amenity', alias?: string  } 
  | { name: 'entertainment', alias?: string  } 
  | { name: 'location', alias?: string  } 
  
export interface UnitUpdateInput {
  type?: number | null
  location?: TileTSUpdateManyInput | null
  cost?: number | null
  baseMoves?: number | null
  combat?: number | null
  range?: number | null
  rangedCombar?: number | null
  bombard?: number | null
}
export type UnitUpdateInputInputObject =
  | Extract<keyof UnitUpdateInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'location', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'baseMoves', alias?: string  } 
  | { name: 'combat', alias?: string  } 
  | { name: 'range', alias?: string  } 
  | { name: 'rangedCombar', alias?: string  } 
  | { name: 'bombard', alias?: string  } 
  
export interface UnitUpdateManyMutationInput {
  type?: number | null
  cost?: number | null
  baseMoves?: number | null
  combat?: number | null
  range?: number | null
  rangedCombar?: number | null
  bombard?: number | null
}
export type UnitUpdateManyMutationInputInputObject =
  | Extract<keyof UnitUpdateManyMutationInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  | { name: 'baseMoves', alias?: string  } 
  | { name: 'combat', alias?: string  } 
  | { name: 'range', alias?: string  } 
  | { name: 'rangedCombar', alias?: string  } 
  | { name: 'bombard', alias?: string  } 
  
export interface TechUpdateInput {
  type?: number | null
  progress?: FloatTSUpdateManyInput | null
  boosted?: BooleanTSUpdateManyInput | null
  cost?: number | null
}
export type TechUpdateInputInputObject =
  | Extract<keyof TechUpdateInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'progress', alias?: string  } 
  | { name: 'boosted', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface TechUpdateManyMutationInput {
  type?: number | null
  cost?: number | null
}
export type TechUpdateManyMutationInputInputObject =
  | Extract<keyof TechUpdateManyMutationInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface CivicUpdateInput {
  type?: number | null
  progress?: FloatTSUpdateManyInput | null
  boosted?: BooleanTSUpdateManyInput | null
  cost?: number | null
}
export type CivicUpdateInputInputObject =
  | Extract<keyof CivicUpdateInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'progress', alias?: string  } 
  | { name: 'boosted', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface CivicUpdateManyMutationInput {
  type?: number | null
  cost?: number | null
}
export type CivicUpdateManyMutationInputInputObject =
  | Extract<keyof CivicUpdateManyMutationInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'cost', alias?: string  } 
  
export interface MapUpdateInput {
  type?: string | null
  tiles?: TileUpdateManyInput | null
}
export type MapUpdateInputInputObject =
  | Extract<keyof MapUpdateInput, string>
  | { name: 'type', alias?: string  } 
  | { name: 'tiles', alias?: string  } 
  
export interface MapUpdateManyMutationInput {
  type?: string | null
}
export type MapUpdateManyMutationInputInputObject =
  | Extract<keyof MapUpdateManyMutationInput, string>
  | { name: 'type', alias?: string  } 
  
export interface TileUpdateInput {
  location?: TileUpdatelocationInput | null
  terrain?: IntTSUpdateManyInput | null
  feature?: IntTSUpdateManyInput | null
}
export type TileUpdateInputInputObject =
  | Extract<keyof TileUpdateInput, string>
  | { name: 'location', alias?: string  } 
  | { name: 'terrain', alias?: string  } 
  | { name: 'feature', alias?: string  } 
  
export interface TileUpdateManyMutationInput {
  location?: TileUpdatelocationInput | null
}
export type TileUpdateManyMutationInputInputObject =
  | Extract<keyof TileUpdateManyMutationInput, string>
  | { name: 'location', alias?: string  } 
  
export interface GameSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: GameWhereInput | null
  AND?: GameSubscriptionWhereInput[]
}
export type GameSubscriptionWhereInputInputObject =
  | Extract<keyof GameSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface LeaderSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: LeaderWhereInput | null
  AND?: LeaderSubscriptionWhereInput[]
}
export type LeaderSubscriptionWhereInputInputObject =
  | Extract<keyof LeaderSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface PlayerSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: PlayerWhereInput | null
  AND?: PlayerSubscriptionWhereInput[]
}
export type PlayerSubscriptionWhereInputInputObject =
  | Extract<keyof PlayerSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface CitySubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: CityWhereInput | null
  AND?: CitySubscriptionWhereInput[]
}
export type CitySubscriptionWhereInputInputObject =
  | Extract<keyof CitySubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface UnitSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: UnitWhereInput | null
  AND?: UnitSubscriptionWhereInput[]
}
export type UnitSubscriptionWhereInputInputObject =
  | Extract<keyof UnitSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface TechSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: TechWhereInput | null
  AND?: TechSubscriptionWhereInput[]
}
export type TechSubscriptionWhereInputInputObject =
  | Extract<keyof TechSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface CivicSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: CivicWhereInput | null
  AND?: CivicSubscriptionWhereInput[]
}
export type CivicSubscriptionWhereInputInputObject =
  | Extract<keyof CivicSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface MapSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: MapWhereInput | null
  AND?: MapSubscriptionWhereInput[]
}
export type MapSubscriptionWhereInputInputObject =
  | Extract<keyof MapSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface TileSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: TileWhereInput | null
  AND?: TileSubscriptionWhereInput[]
}
export type TileSubscriptionWhereInputInputObject =
  | Extract<keyof TileSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  

export type LeaderOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  
export type CityOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  
export type TechOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'type_ASC'
  | 'type_DESC'
  | 'cost_ASC'
  | 'cost_DESC'
  
export type CivicOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'type_ASC'
  | 'type_DESC'
  | 'cost_ASC'
  | 'cost_DESC'
  
export type UnitOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'type_ASC'
  | 'type_DESC'
  | 'cost_ASC'
  | 'cost_DESC'
  | 'baseMoves_ASC'
  | 'baseMoves_DESC'
  | 'combat_ASC'
  | 'combat_DESC'
  | 'range_ASC'
  | 'range_DESC'
  | 'rangedCombar_ASC'
  | 'rangedCombar_DESC'
  | 'bombard_ASC'
  | 'bombard_DESC'
  
export type TileOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  
export type GameOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  
export type PlayerOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  
export type MapOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'type_ASC'
  | 'type_DESC'
  
export type MutationTypeValues =
  | 'CREATED'
  | 'UPDATED'
  | 'DELETED'
  
  