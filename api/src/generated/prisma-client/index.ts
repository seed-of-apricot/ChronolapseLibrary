// Code generated by Prisma (prisma@1.35.0-beta). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  city: (where?: CityWhereInput) => Promise<boolean>;
  civic: (where?: CivicWhereInput) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  leader: (where?: LeaderWhereInput) => Promise<boolean>;
  map: (where?: MapWhereInput) => Promise<boolean>;
  player: (where?: PlayerWhereInput) => Promise<boolean>;
  tech: (where?: TechWhereInput) => Promise<boolean>;
  tile: (where?: TileWhereInput) => Promise<boolean>;
  unit: (where?: UnitWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  city: (where: CityWhereUniqueInput) => CityNullablePromise;
  cities: (args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<City>;
  citiesConnection: (args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CityConnectionPromise;
  civic: (where: CivicWhereUniqueInput) => CivicNullablePromise;
  civics: (args?: {
    where?: CivicWhereInput;
    orderBy?: CivicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Civic>;
  civicsConnection: (args?: {
    where?: CivicWhereInput;
    orderBy?: CivicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CivicConnectionPromise;
  game: (where: GameWhereUniqueInput) => GameNullablePromise;
  games: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Game>;
  gamesConnection: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameConnectionPromise;
  leader: (where: LeaderWhereUniqueInput) => LeaderNullablePromise;
  leaders: (args?: {
    where?: LeaderWhereInput;
    orderBy?: LeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Leader>;
  leadersConnection: (args?: {
    where?: LeaderWhereInput;
    orderBy?: LeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LeaderConnectionPromise;
  map: (where: MapWhereUniqueInput) => MapNullablePromise;
  maps: (args?: {
    where?: MapWhereInput;
    orderBy?: MapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Map>;
  mapsConnection: (args?: {
    where?: MapWhereInput;
    orderBy?: MapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MapConnectionPromise;
  player: (where: PlayerWhereUniqueInput) => PlayerNullablePromise;
  players: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Player>;
  playersConnection: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlayerConnectionPromise;
  tech: (where: TechWhereUniqueInput) => TechNullablePromise;
  teches: (args?: {
    where?: TechWhereInput;
    orderBy?: TechOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tech>;
  techesConnection: (args?: {
    where?: TechWhereInput;
    orderBy?: TechOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TechConnectionPromise;
  tile: (where: TileWhereUniqueInput) => TileNullablePromise;
  tiles: (args?: {
    where?: TileWhereInput;
    orderBy?: TileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tile>;
  tilesConnection: (args?: {
    where?: TileWhereInput;
    orderBy?: TileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TileConnectionPromise;
  unit: (where: UnitWhereUniqueInput) => UnitNullablePromise;
  units: (args?: {
    where?: UnitWhereInput;
    orderBy?: UnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Unit>;
  unitsConnection: (args?: {
    where?: UnitWhereInput;
    orderBy?: UnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UnitConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCity: (data: CityCreateInput) => CityPromise;
  updateCity: (args: {
    data: CityUpdateInput;
    where: CityWhereUniqueInput;
  }) => CityPromise;
  upsertCity: (args: {
    where: CityWhereUniqueInput;
    create: CityCreateInput;
    update: CityUpdateInput;
  }) => CityPromise;
  deleteCity: (where: CityWhereUniqueInput) => CityPromise;
  deleteManyCities: (where?: CityWhereInput) => BatchPayloadPromise;
  createCivic: (data: CivicCreateInput) => CivicPromise;
  updateCivic: (args: {
    data: CivicUpdateInput;
    where: CivicWhereUniqueInput;
  }) => CivicPromise;
  updateManyCivics: (args: {
    data: CivicUpdateManyMutationInput;
    where?: CivicWhereInput;
  }) => BatchPayloadPromise;
  upsertCivic: (args: {
    where: CivicWhereUniqueInput;
    create: CivicCreateInput;
    update: CivicUpdateInput;
  }) => CivicPromise;
  deleteCivic: (where: CivicWhereUniqueInput) => CivicPromise;
  deleteManyCivics: (where?: CivicWhereInput) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (args: {
    data: GameUpdateInput;
    where: GameWhereUniqueInput;
  }) => GamePromise;
  updateManyGames: (args: {
    data: GameUpdateManyMutationInput;
    where?: GameWhereInput;
  }) => BatchPayloadPromise;
  upsertGame: (args: {
    where: GameWhereUniqueInput;
    create: GameCreateInput;
    update: GameUpdateInput;
  }) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createLeader: (data: LeaderCreateInput) => LeaderPromise;
  updateLeader: (args: {
    data: LeaderUpdateInput;
    where: LeaderWhereUniqueInput;
  }) => LeaderPromise;
  updateManyLeaders: (args: {
    data: LeaderUpdateManyMutationInput;
    where?: LeaderWhereInput;
  }) => BatchPayloadPromise;
  upsertLeader: (args: {
    where: LeaderWhereUniqueInput;
    create: LeaderCreateInput;
    update: LeaderUpdateInput;
  }) => LeaderPromise;
  deleteLeader: (where: LeaderWhereUniqueInput) => LeaderPromise;
  deleteManyLeaders: (where?: LeaderWhereInput) => BatchPayloadPromise;
  createMap: (data: MapCreateInput) => MapPromise;
  updateMap: (args: {
    data: MapUpdateInput;
    where: MapWhereUniqueInput;
  }) => MapPromise;
  updateManyMaps: (args: {
    data: MapUpdateManyMutationInput;
    where?: MapWhereInput;
  }) => BatchPayloadPromise;
  upsertMap: (args: {
    where: MapWhereUniqueInput;
    create: MapCreateInput;
    update: MapUpdateInput;
  }) => MapPromise;
  deleteMap: (where: MapWhereUniqueInput) => MapPromise;
  deleteManyMaps: (where?: MapWhereInput) => BatchPayloadPromise;
  createPlayer: (data: PlayerCreateInput) => PlayerPromise;
  updatePlayer: (args: {
    data: PlayerUpdateInput;
    where: PlayerWhereUniqueInput;
  }) => PlayerPromise;
  upsertPlayer: (args: {
    where: PlayerWhereUniqueInput;
    create: PlayerCreateInput;
    update: PlayerUpdateInput;
  }) => PlayerPromise;
  deletePlayer: (where: PlayerWhereUniqueInput) => PlayerPromise;
  deleteManyPlayers: (where?: PlayerWhereInput) => BatchPayloadPromise;
  createTech: (data: TechCreateInput) => TechPromise;
  updateTech: (args: {
    data: TechUpdateInput;
    where: TechWhereUniqueInput;
  }) => TechPromise;
  updateManyTeches: (args: {
    data: TechUpdateManyMutationInput;
    where?: TechWhereInput;
  }) => BatchPayloadPromise;
  upsertTech: (args: {
    where: TechWhereUniqueInput;
    create: TechCreateInput;
    update: TechUpdateInput;
  }) => TechPromise;
  deleteTech: (where: TechWhereUniqueInput) => TechPromise;
  deleteManyTeches: (where?: TechWhereInput) => BatchPayloadPromise;
  createTile: (data: TileCreateInput) => TilePromise;
  updateTile: (args: {
    data: TileUpdateInput;
    where: TileWhereUniqueInput;
  }) => TilePromise;
  updateManyTiles: (args: {
    data: TileUpdateManyMutationInput;
    where?: TileWhereInput;
  }) => BatchPayloadPromise;
  upsertTile: (args: {
    where: TileWhereUniqueInput;
    create: TileCreateInput;
    update: TileUpdateInput;
  }) => TilePromise;
  deleteTile: (where: TileWhereUniqueInput) => TilePromise;
  deleteManyTiles: (where?: TileWhereInput) => BatchPayloadPromise;
  createUnit: (data: UnitCreateInput) => UnitPromise;
  updateUnit: (args: {
    data: UnitUpdateInput;
    where: UnitWhereUniqueInput;
  }) => UnitPromise;
  updateManyUnits: (args: {
    data: UnitUpdateManyMutationInput;
    where?: UnitWhereInput;
  }) => BatchPayloadPromise;
  upsertUnit: (args: {
    where: UnitWhereUniqueInput;
    create: UnitCreateInput;
    update: UnitUpdateInput;
  }) => UnitPromise;
  deleteUnit: (where: UnitWhereUniqueInput) => UnitPromise;
  deleteManyUnits: (where?: UnitWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  civic: (
    where?: CivicSubscriptionWhereInput
  ) => CivicSubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  leader: (
    where?: LeaderSubscriptionWhereInput
  ) => LeaderSubscriptionPayloadSubscription;
  map: (
    where?: MapSubscriptionWhereInput
  ) => MapSubscriptionPayloadSubscription;
  player: (
    where?: PlayerSubscriptionWhereInput
  ) => PlayerSubscriptionPayloadSubscription;
  tech: (
    where?: TechSubscriptionWhereInput
  ) => TechSubscriptionPayloadSubscription;
  tile: (
    where?: TileSubscriptionWhereInput
  ) => TileSubscriptionPayloadSubscription;
  unit: (
    where?: UnitSubscriptionWhereInput
  ) => UnitSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CityOrderByInput = "id_ASC" | "id_DESC";

export type CivicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "cost_ASC"
  | "cost_DESC";

export type LeaderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type TechOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "cost_ASC"
  | "cost_DESC";

export type UnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "cost_ASC"
  | "cost_DESC"
  | "baseMoves_ASC"
  | "baseMoves_DESC"
  | "combat_ASC"
  | "combat_DESC"
  | "range_ASC"
  | "range_DESC"
  | "rangedCombar_ASC"
  | "rangedCombar_DESC"
  | "bombard_ASC"
  | "bombard_DESC";

export type TileOrderByInput = "id_ASC" | "id_DESC";

export type GameOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type MapOrderByInput = "id_ASC" | "id_DESC" | "type_ASC" | "type_DESC";

export type PlayerOrderByInput = "id_ASC" | "id_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name_some?: Maybe<StringTSWhereInput>;
  name_every?: Maybe<StringTSRestrictedWhereInput>;
  name_none?: Maybe<StringTSRestrictedWhereInput>;
  isExist_some?: Maybe<BooleanTSWhereInput>;
  isExist_every?: Maybe<BooleanTSRestrictedWhereInput>;
  isExist_none?: Maybe<BooleanTSRestrictedWhereInput>;
  population_some?: Maybe<IntTSWhereInput>;
  population_every?: Maybe<IntTSRestrictedWhereInput>;
  population_none?: Maybe<IntTSRestrictedWhereInput>;
  amenity_some?: Maybe<IntTSWhereInput>;
  amenity_every?: Maybe<IntTSRestrictedWhereInput>;
  amenity_none?: Maybe<IntTSRestrictedWhereInput>;
  entertainment_some?: Maybe<IntTSWhereInput>;
  entertainment_every?: Maybe<IntTSRestrictedWhereInput>;
  entertainment_none?: Maybe<IntTSRestrictedWhereInput>;
  location_some?: Maybe<TileTSWhereInput>;
  location_every?: Maybe<TileTSRestrictedWhereInput>;
  location_none?: Maybe<TileTSRestrictedWhereInput>;
  AND?: Maybe<CityWhereInput[] | CityWhereInput>;
}

export interface StringTSWhereInput {
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StringTSWhereInput[] | StringTSWhereInput>;
}

export interface StringTSRestrictedWhereInput {
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StringTSRestrictedWhereInput[] | StringTSRestrictedWhereInput>;
}

export interface BooleanTSWhereInput {
  value?: Maybe<Boolean>;
  value_not?: Maybe<Boolean>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BooleanTSWhereInput[] | BooleanTSWhereInput>;
}

export interface BooleanTSRestrictedWhereInput {
  value?: Maybe<Boolean>;
  value_not?: Maybe<Boolean>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BooleanTSRestrictedWhereInput[] | BooleanTSRestrictedWhereInput>;
}

export interface IntTSWhereInput {
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<IntTSWhereInput[] | IntTSWhereInput>;
}

export interface IntTSRestrictedWhereInput {
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<IntTSRestrictedWhereInput[] | IntTSRestrictedWhereInput>;
}

export interface TileTSWhereInput {
  value?: Maybe<TileWhereInput>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TileTSWhereInput[] | TileTSWhereInput>;
}

export interface TileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  terrain_some?: Maybe<IntTSWhereInput>;
  terrain_every?: Maybe<IntTSRestrictedWhereInput>;
  terrain_none?: Maybe<IntTSRestrictedWhereInput>;
  feature_some?: Maybe<IntTSWhereInput>;
  feature_every?: Maybe<IntTSRestrictedWhereInput>;
  feature_none?: Maybe<IntTSRestrictedWhereInput>;
  AND?: Maybe<TileWhereInput[] | TileWhereInput>;
}

export interface TileTSRestrictedWhereInput {
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TileTSRestrictedWhereInput[] | TileTSRestrictedWhereInput>;
}

export type CivicWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CivicWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  progress_some?: Maybe<FloatTSWhereInput>;
  progress_every?: Maybe<FloatTSRestrictedWhereInput>;
  progress_none?: Maybe<FloatTSRestrictedWhereInput>;
  boosted_some?: Maybe<BooleanTSWhereInput>;
  boosted_every?: Maybe<BooleanTSRestrictedWhereInput>;
  boosted_none?: Maybe<BooleanTSRestrictedWhereInput>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  AND?: Maybe<CivicWhereInput[] | CivicWhereInput>;
}

export interface FloatTSWhereInput {
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FloatTSWhereInput[] | FloatTSWhereInput>;
}

export interface FloatTSRestrictedWhereInput {
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FloatTSRestrictedWhereInput[] | FloatTSRestrictedWhereInput>;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LeaderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  player?: Maybe<PlayerWhereInput>;
  cities_some?: Maybe<CityWhereInput>;
  techs_some?: Maybe<TechWhereInput>;
  civics_some?: Maybe<CivicWhereInput>;
  units_some?: Maybe<UnitWhereInput>;
  AND?: Maybe<LeaderWhereInput[] | LeaderWhereInput>;
}

export interface PlayerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name_some?: Maybe<StringTSWhereInput>;
  name_every?: Maybe<StringTSRestrictedWhereInput>;
  name_none?: Maybe<StringTSRestrictedWhereInput>;
  isHuman_some?: Maybe<BooleanTSWhereInput>;
  isHuman_every?: Maybe<BooleanTSRestrictedWhereInput>;
  isHuman_none?: Maybe<BooleanTSRestrictedWhereInput>;
  AND?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
}

export interface TechWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  progress_some?: Maybe<FloatTSWhereInput>;
  progress_every?: Maybe<FloatTSRestrictedWhereInput>;
  progress_none?: Maybe<FloatTSRestrictedWhereInput>;
  boosted_some?: Maybe<BooleanTSWhereInput>;
  boosted_every?: Maybe<BooleanTSRestrictedWhereInput>;
  boosted_none?: Maybe<BooleanTSRestrictedWhereInput>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  AND?: Maybe<TechWhereInput[] | TechWhereInput>;
}

export interface UnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  location_some?: Maybe<TileTSWhereInput>;
  location_every?: Maybe<TileTSRestrictedWhereInput>;
  location_none?: Maybe<TileTSRestrictedWhereInput>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  baseMoves?: Maybe<Int>;
  baseMoves_not?: Maybe<Int>;
  baseMoves_in?: Maybe<Int[] | Int>;
  baseMoves_not_in?: Maybe<Int[] | Int>;
  baseMoves_lt?: Maybe<Int>;
  baseMoves_lte?: Maybe<Int>;
  baseMoves_gt?: Maybe<Int>;
  baseMoves_gte?: Maybe<Int>;
  combat?: Maybe<Int>;
  combat_not?: Maybe<Int>;
  combat_in?: Maybe<Int[] | Int>;
  combat_not_in?: Maybe<Int[] | Int>;
  combat_lt?: Maybe<Int>;
  combat_lte?: Maybe<Int>;
  combat_gt?: Maybe<Int>;
  combat_gte?: Maybe<Int>;
  range?: Maybe<Int>;
  range_not?: Maybe<Int>;
  range_in?: Maybe<Int[] | Int>;
  range_not_in?: Maybe<Int[] | Int>;
  range_lt?: Maybe<Int>;
  range_lte?: Maybe<Int>;
  range_gt?: Maybe<Int>;
  range_gte?: Maybe<Int>;
  rangedCombar?: Maybe<Int>;
  rangedCombar_not?: Maybe<Int>;
  rangedCombar_in?: Maybe<Int[] | Int>;
  rangedCombar_not_in?: Maybe<Int[] | Int>;
  rangedCombar_lt?: Maybe<Int>;
  rangedCombar_lte?: Maybe<Int>;
  rangedCombar_gt?: Maybe<Int>;
  rangedCombar_gte?: Maybe<Int>;
  bombard?: Maybe<Int>;
  bombard_not?: Maybe<Int>;
  bombard_in?: Maybe<Int[] | Int>;
  bombard_not_in?: Maybe<Int[] | Int>;
  bombard_lt?: Maybe<Int>;
  bombard_lte?: Maybe<Int>;
  bombard_gt?: Maybe<Int>;
  bombard_gte?: Maybe<Int>;
  AND?: Maybe<UnitWhereInput[] | UnitWhereInput>;
}

export interface GameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  leaders_some?: Maybe<LeaderWhereInput>;
  map?: Maybe<MapWhereInput>;
  AND?: Maybe<GameWhereInput[] | GameWhereInput>;
}

export interface MapWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  tiles_some?: Maybe<TileWhereInput>;
  AND?: Maybe<MapWhereInput[] | MapWhereInput>;
}

export type LeaderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MapWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PlayerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TechWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CityCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<StringTSCreateManyInput>;
  isExist?: Maybe<BooleanTSCreateManyInput>;
  population?: Maybe<IntTSCreateManyInput>;
  amenity?: Maybe<IntTSCreateManyInput>;
  entertainment?: Maybe<IntTSCreateManyInput>;
  location?: Maybe<TileTSCreateManyInput>;
}

export interface StringTSCreateManyInput {
  create?: Maybe<StringTSCreateInput[] | StringTSCreateInput>;
}

export interface StringTSCreateInput {
  value: String;
}

export interface BooleanTSCreateManyInput {
  create?: Maybe<BooleanTSCreateInput[] | BooleanTSCreateInput>;
}

export interface BooleanTSCreateInput {
  value: Boolean;
}

export interface IntTSCreateManyInput {
  create?: Maybe<IntTSCreateInput[] | IntTSCreateInput>;
}

export interface IntTSCreateInput {
  value: Int;
}

export interface TileTSCreateManyInput {
  create?: Maybe<TileTSCreateInput[] | TileTSCreateInput>;
}

export interface TileTSCreateInput {
  value: TileCreateOneInput;
}

export interface TileCreateOneInput {
  create?: Maybe<TileCreateInput>;
  connect?: Maybe<TileWhereUniqueInput>;
}

export interface TileCreateInput {
  id?: Maybe<ID_Input>;
  location?: Maybe<TileCreatelocationInput>;
  terrain?: Maybe<IntTSCreateManyInput>;
  feature?: Maybe<IntTSCreateManyInput>;
}

export interface TileCreatelocationInput {
  set?: Maybe<Int[] | Int>;
}

export interface CityUpdateInput {
  name?: Maybe<StringTSUpdateManyInput>;
  isExist?: Maybe<BooleanTSUpdateManyInput>;
  population?: Maybe<IntTSUpdateManyInput>;
  amenity?: Maybe<IntTSUpdateManyInput>;
  entertainment?: Maybe<IntTSUpdateManyInput>;
  location?: Maybe<TileTSUpdateManyInput>;
}

export interface StringTSUpdateManyInput {
  create?: Maybe<StringTSCreateInput[] | StringTSCreateInput>;
  deleteMany?: Maybe<StringTSScalarWhereInput[] | StringTSScalarWhereInput>;
  updateMany?: Maybe<
    | StringTSUpdateManyWithWhereNestedInput[]
    | StringTSUpdateManyWithWhereNestedInput
  >;
}

export interface StringTSScalarWhereInput {
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StringTSScalarWhereInput[] | StringTSScalarWhereInput>;
  OR?: Maybe<StringTSScalarWhereInput[] | StringTSScalarWhereInput>;
  NOT?: Maybe<StringTSScalarWhereInput[] | StringTSScalarWhereInput>;
}

export interface StringTSUpdateManyWithWhereNestedInput {
  where: StringTSScalarWhereInput;
  data: StringTSUpdateManyDataInput;
}

export interface StringTSUpdateManyDataInput {
  value?: Maybe<String>;
}

export interface BooleanTSUpdateManyInput {
  create?: Maybe<BooleanTSCreateInput[] | BooleanTSCreateInput>;
  deleteMany?: Maybe<BooleanTSScalarWhereInput[] | BooleanTSScalarWhereInput>;
  updateMany?: Maybe<
    | BooleanTSUpdateManyWithWhereNestedInput[]
    | BooleanTSUpdateManyWithWhereNestedInput
  >;
}

export interface BooleanTSScalarWhereInput {
  value?: Maybe<Boolean>;
  value_not?: Maybe<Boolean>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BooleanTSScalarWhereInput[] | BooleanTSScalarWhereInput>;
  OR?: Maybe<BooleanTSScalarWhereInput[] | BooleanTSScalarWhereInput>;
  NOT?: Maybe<BooleanTSScalarWhereInput[] | BooleanTSScalarWhereInput>;
}

export interface BooleanTSUpdateManyWithWhereNestedInput {
  where: BooleanTSScalarWhereInput;
  data: BooleanTSUpdateManyDataInput;
}

export interface BooleanTSUpdateManyDataInput {
  value?: Maybe<Boolean>;
}

export interface IntTSUpdateManyInput {
  create?: Maybe<IntTSCreateInput[] | IntTSCreateInput>;
  deleteMany?: Maybe<IntTSScalarWhereInput[] | IntTSScalarWhereInput>;
  updateMany?: Maybe<
    IntTSUpdateManyWithWhereNestedInput[] | IntTSUpdateManyWithWhereNestedInput
  >;
}

export interface IntTSScalarWhereInput {
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<IntTSScalarWhereInput[] | IntTSScalarWhereInput>;
  OR?: Maybe<IntTSScalarWhereInput[] | IntTSScalarWhereInput>;
  NOT?: Maybe<IntTSScalarWhereInput[] | IntTSScalarWhereInput>;
}

export interface IntTSUpdateManyWithWhereNestedInput {
  where: IntTSScalarWhereInput;
  data: IntTSUpdateManyDataInput;
}

export interface IntTSUpdateManyDataInput {
  value?: Maybe<Int>;
}

export interface TileTSUpdateManyInput {
  create?: Maybe<TileTSCreateInput[] | TileTSCreateInput>;
  deleteMany?: Maybe<TileTSScalarWhereInput[] | TileTSScalarWhereInput>;
}

export interface TileTSScalarWhereInput {
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TileTSScalarWhereInput[] | TileTSScalarWhereInput>;
  OR?: Maybe<TileTSScalarWhereInput[] | TileTSScalarWhereInput>;
  NOT?: Maybe<TileTSScalarWhereInput[] | TileTSScalarWhereInput>;
}

export interface CivicCreateInput {
  id?: Maybe<ID_Input>;
  type: Int;
  progress?: Maybe<FloatTSCreateManyInput>;
  boosted?: Maybe<BooleanTSCreateManyInput>;
  cost: Int;
}

export interface FloatTSCreateManyInput {
  create?: Maybe<FloatTSCreateInput[] | FloatTSCreateInput>;
}

export interface FloatTSCreateInput {
  value: Float;
}

export interface CivicUpdateInput {
  type?: Maybe<Int>;
  progress?: Maybe<FloatTSUpdateManyInput>;
  boosted?: Maybe<BooleanTSUpdateManyInput>;
  cost?: Maybe<Int>;
}

export interface FloatTSUpdateManyInput {
  create?: Maybe<FloatTSCreateInput[] | FloatTSCreateInput>;
  deleteMany?: Maybe<FloatTSScalarWhereInput[] | FloatTSScalarWhereInput>;
  updateMany?: Maybe<
    | FloatTSUpdateManyWithWhereNestedInput[]
    | FloatTSUpdateManyWithWhereNestedInput
  >;
}

export interface FloatTSScalarWhereInput {
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FloatTSScalarWhereInput[] | FloatTSScalarWhereInput>;
  OR?: Maybe<FloatTSScalarWhereInput[] | FloatTSScalarWhereInput>;
  NOT?: Maybe<FloatTSScalarWhereInput[] | FloatTSScalarWhereInput>;
}

export interface FloatTSUpdateManyWithWhereNestedInput {
  where: FloatTSScalarWhereInput;
  data: FloatTSUpdateManyDataInput;
}

export interface FloatTSUpdateManyDataInput {
  value?: Maybe<Float>;
}

export interface CivicUpdateManyMutationInput {
  type?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface GameCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  leaders?: Maybe<LeaderCreateManyInput>;
  map: MapCreateOneInput;
}

export interface LeaderCreateManyInput {
  create?: Maybe<LeaderCreateInput[] | LeaderCreateInput>;
  connect?: Maybe<LeaderWhereUniqueInput[] | LeaderWhereUniqueInput>;
}

export interface LeaderCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  player: PlayerCreateOneInput;
  cities?: Maybe<CityCreateManyInput>;
  techs?: Maybe<TechCreateManyInput>;
  civics?: Maybe<CivicCreateManyInput>;
  units?: Maybe<UnitCreateManyInput>;
}

export interface PlayerCreateOneInput {
  create?: Maybe<PlayerCreateInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<StringTSCreateManyInput>;
  isHuman?: Maybe<BooleanTSCreateManyInput>;
}

export interface CityCreateManyInput {
  create?: Maybe<CityCreateInput[] | CityCreateInput>;
  connect?: Maybe<CityWhereUniqueInput[] | CityWhereUniqueInput>;
}

export interface TechCreateManyInput {
  create?: Maybe<TechCreateInput[] | TechCreateInput>;
  connect?: Maybe<TechWhereUniqueInput[] | TechWhereUniqueInput>;
}

export interface TechCreateInput {
  id?: Maybe<ID_Input>;
  type: Int;
  progress?: Maybe<FloatTSCreateManyInput>;
  boosted?: Maybe<BooleanTSCreateManyInput>;
  cost: Int;
}

export interface CivicCreateManyInput {
  create?: Maybe<CivicCreateInput[] | CivicCreateInput>;
  connect?: Maybe<CivicWhereUniqueInput[] | CivicWhereUniqueInput>;
}

export interface UnitCreateManyInput {
  create?: Maybe<UnitCreateInput[] | UnitCreateInput>;
  connect?: Maybe<UnitWhereUniqueInput[] | UnitWhereUniqueInput>;
}

export interface UnitCreateInput {
  id?: Maybe<ID_Input>;
  type: Int;
  location?: Maybe<TileTSCreateManyInput>;
  cost: Int;
  baseMoves?: Maybe<Int>;
  combat?: Maybe<Int>;
  range?: Maybe<Int>;
  rangedCombar?: Maybe<Int>;
  bombard?: Maybe<Int>;
}

export interface MapCreateOneInput {
  create?: Maybe<MapCreateInput>;
  connect?: Maybe<MapWhereUniqueInput>;
}

export interface MapCreateInput {
  id?: Maybe<ID_Input>;
  type: String;
  tiles?: Maybe<TileCreateManyInput>;
}

export interface TileCreateManyInput {
  create?: Maybe<TileCreateInput[] | TileCreateInput>;
  connect?: Maybe<TileWhereUniqueInput[] | TileWhereUniqueInput>;
}

export interface GameUpdateInput {
  name?: Maybe<String>;
  leaders?: Maybe<LeaderUpdateManyInput>;
  map?: Maybe<MapUpdateOneRequiredInput>;
}

export interface LeaderUpdateManyInput {
  create?: Maybe<LeaderCreateInput[] | LeaderCreateInput>;
  update?: Maybe<
    | LeaderUpdateWithWhereUniqueNestedInput[]
    | LeaderUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | LeaderUpsertWithWhereUniqueNestedInput[]
    | LeaderUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<LeaderWhereUniqueInput[] | LeaderWhereUniqueInput>;
  connect?: Maybe<LeaderWhereUniqueInput[] | LeaderWhereUniqueInput>;
  set?: Maybe<LeaderWhereUniqueInput[] | LeaderWhereUniqueInput>;
  disconnect?: Maybe<LeaderWhereUniqueInput[] | LeaderWhereUniqueInput>;
  deleteMany?: Maybe<LeaderScalarWhereInput[] | LeaderScalarWhereInput>;
  updateMany?: Maybe<
    | LeaderUpdateManyWithWhereNestedInput[]
    | LeaderUpdateManyWithWhereNestedInput
  >;
}

export interface LeaderUpdateWithWhereUniqueNestedInput {
  where: LeaderWhereUniqueInput;
  data: LeaderUpdateDataInput;
}

export interface LeaderUpdateDataInput {
  name?: Maybe<String>;
  player?: Maybe<PlayerUpdateOneRequiredInput>;
  cities?: Maybe<CityUpdateManyInput>;
  techs?: Maybe<TechUpdateManyInput>;
  civics?: Maybe<CivicUpdateManyInput>;
  units?: Maybe<UnitUpdateManyInput>;
}

export interface PlayerUpdateOneRequiredInput {
  create?: Maybe<PlayerCreateInput>;
  update?: Maybe<PlayerUpdateDataInput>;
  upsert?: Maybe<PlayerUpsertNestedInput>;
  connect?: Maybe<PlayerWhereUniqueInput>;
}

export interface PlayerUpdateDataInput {
  name?: Maybe<StringTSUpdateManyInput>;
  isHuman?: Maybe<BooleanTSUpdateManyInput>;
}

export interface PlayerUpsertNestedInput {
  update: PlayerUpdateDataInput;
  create: PlayerCreateInput;
}

export interface CityUpdateManyInput {
  create?: Maybe<CityCreateInput[] | CityCreateInput>;
  update?: Maybe<
    | CityUpdateWithWhereUniqueNestedInput[]
    | CityUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | CityUpsertWithWhereUniqueNestedInput[]
    | CityUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<CityWhereUniqueInput[] | CityWhereUniqueInput>;
  connect?: Maybe<CityWhereUniqueInput[] | CityWhereUniqueInput>;
  set?: Maybe<CityWhereUniqueInput[] | CityWhereUniqueInput>;
  disconnect?: Maybe<CityWhereUniqueInput[] | CityWhereUniqueInput>;
  deleteMany?: Maybe<CityScalarWhereInput[] | CityScalarWhereInput>;
}

export interface CityUpdateWithWhereUniqueNestedInput {
  where: CityWhereUniqueInput;
  data: CityUpdateDataInput;
}

export interface CityUpdateDataInput {
  name?: Maybe<StringTSUpdateManyInput>;
  isExist?: Maybe<BooleanTSUpdateManyInput>;
  population?: Maybe<IntTSUpdateManyInput>;
  amenity?: Maybe<IntTSUpdateManyInput>;
  entertainment?: Maybe<IntTSUpdateManyInput>;
  location?: Maybe<TileTSUpdateManyInput>;
}

export interface CityUpsertWithWhereUniqueNestedInput {
  where: CityWhereUniqueInput;
  update: CityUpdateDataInput;
  create: CityCreateInput;
}

export interface CityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<CityScalarWhereInput[] | CityScalarWhereInput>;
  OR?: Maybe<CityScalarWhereInput[] | CityScalarWhereInput>;
  NOT?: Maybe<CityScalarWhereInput[] | CityScalarWhereInput>;
}

export interface TechUpdateManyInput {
  create?: Maybe<TechCreateInput[] | TechCreateInput>;
  update?: Maybe<
    | TechUpdateWithWhereUniqueNestedInput[]
    | TechUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | TechUpsertWithWhereUniqueNestedInput[]
    | TechUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TechWhereUniqueInput[] | TechWhereUniqueInput>;
  connect?: Maybe<TechWhereUniqueInput[] | TechWhereUniqueInput>;
  set?: Maybe<TechWhereUniqueInput[] | TechWhereUniqueInput>;
  disconnect?: Maybe<TechWhereUniqueInput[] | TechWhereUniqueInput>;
  deleteMany?: Maybe<TechScalarWhereInput[] | TechScalarWhereInput>;
  updateMany?: Maybe<
    TechUpdateManyWithWhereNestedInput[] | TechUpdateManyWithWhereNestedInput
  >;
}

export interface TechUpdateWithWhereUniqueNestedInput {
  where: TechWhereUniqueInput;
  data: TechUpdateDataInput;
}

export interface TechUpdateDataInput {
  type?: Maybe<Int>;
  progress?: Maybe<FloatTSUpdateManyInput>;
  boosted?: Maybe<BooleanTSUpdateManyInput>;
  cost?: Maybe<Int>;
}

export interface TechUpsertWithWhereUniqueNestedInput {
  where: TechWhereUniqueInput;
  update: TechUpdateDataInput;
  create: TechCreateInput;
}

export interface TechScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  AND?: Maybe<TechScalarWhereInput[] | TechScalarWhereInput>;
  OR?: Maybe<TechScalarWhereInput[] | TechScalarWhereInput>;
  NOT?: Maybe<TechScalarWhereInput[] | TechScalarWhereInput>;
}

export interface TechUpdateManyWithWhereNestedInput {
  where: TechScalarWhereInput;
  data: TechUpdateManyDataInput;
}

export interface TechUpdateManyDataInput {
  type?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface CivicUpdateManyInput {
  create?: Maybe<CivicCreateInput[] | CivicCreateInput>;
  update?: Maybe<
    | CivicUpdateWithWhereUniqueNestedInput[]
    | CivicUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | CivicUpsertWithWhereUniqueNestedInput[]
    | CivicUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<CivicWhereUniqueInput[] | CivicWhereUniqueInput>;
  connect?: Maybe<CivicWhereUniqueInput[] | CivicWhereUniqueInput>;
  set?: Maybe<CivicWhereUniqueInput[] | CivicWhereUniqueInput>;
  disconnect?: Maybe<CivicWhereUniqueInput[] | CivicWhereUniqueInput>;
  deleteMany?: Maybe<CivicScalarWhereInput[] | CivicScalarWhereInput>;
  updateMany?: Maybe<
    CivicUpdateManyWithWhereNestedInput[] | CivicUpdateManyWithWhereNestedInput
  >;
}

export interface CivicUpdateWithWhereUniqueNestedInput {
  where: CivicWhereUniqueInput;
  data: CivicUpdateDataInput;
}

export interface CivicUpdateDataInput {
  type?: Maybe<Int>;
  progress?: Maybe<FloatTSUpdateManyInput>;
  boosted?: Maybe<BooleanTSUpdateManyInput>;
  cost?: Maybe<Int>;
}

export interface CivicUpsertWithWhereUniqueNestedInput {
  where: CivicWhereUniqueInput;
  update: CivicUpdateDataInput;
  create: CivicCreateInput;
}

export interface CivicScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  AND?: Maybe<CivicScalarWhereInput[] | CivicScalarWhereInput>;
  OR?: Maybe<CivicScalarWhereInput[] | CivicScalarWhereInput>;
  NOT?: Maybe<CivicScalarWhereInput[] | CivicScalarWhereInput>;
}

export interface CivicUpdateManyWithWhereNestedInput {
  where: CivicScalarWhereInput;
  data: CivicUpdateManyDataInput;
}

export interface CivicUpdateManyDataInput {
  type?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface UnitUpdateManyInput {
  create?: Maybe<UnitCreateInput[] | UnitCreateInput>;
  update?: Maybe<
    | UnitUpdateWithWhereUniqueNestedInput[]
    | UnitUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UnitUpsertWithWhereUniqueNestedInput[]
    | UnitUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UnitWhereUniqueInput[] | UnitWhereUniqueInput>;
  connect?: Maybe<UnitWhereUniqueInput[] | UnitWhereUniqueInput>;
  set?: Maybe<UnitWhereUniqueInput[] | UnitWhereUniqueInput>;
  disconnect?: Maybe<UnitWhereUniqueInput[] | UnitWhereUniqueInput>;
  deleteMany?: Maybe<UnitScalarWhereInput[] | UnitScalarWhereInput>;
  updateMany?: Maybe<
    UnitUpdateManyWithWhereNestedInput[] | UnitUpdateManyWithWhereNestedInput
  >;
}

export interface UnitUpdateWithWhereUniqueNestedInput {
  where: UnitWhereUniqueInput;
  data: UnitUpdateDataInput;
}

export interface UnitUpdateDataInput {
  type?: Maybe<Int>;
  location?: Maybe<TileTSUpdateManyInput>;
  cost?: Maybe<Int>;
  baseMoves?: Maybe<Int>;
  combat?: Maybe<Int>;
  range?: Maybe<Int>;
  rangedCombar?: Maybe<Int>;
  bombard?: Maybe<Int>;
}

export interface UnitUpsertWithWhereUniqueNestedInput {
  where: UnitWhereUniqueInput;
  update: UnitUpdateDataInput;
  create: UnitCreateInput;
}

export interface UnitScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  baseMoves?: Maybe<Int>;
  baseMoves_not?: Maybe<Int>;
  baseMoves_in?: Maybe<Int[] | Int>;
  baseMoves_not_in?: Maybe<Int[] | Int>;
  baseMoves_lt?: Maybe<Int>;
  baseMoves_lte?: Maybe<Int>;
  baseMoves_gt?: Maybe<Int>;
  baseMoves_gte?: Maybe<Int>;
  combat?: Maybe<Int>;
  combat_not?: Maybe<Int>;
  combat_in?: Maybe<Int[] | Int>;
  combat_not_in?: Maybe<Int[] | Int>;
  combat_lt?: Maybe<Int>;
  combat_lte?: Maybe<Int>;
  combat_gt?: Maybe<Int>;
  combat_gte?: Maybe<Int>;
  range?: Maybe<Int>;
  range_not?: Maybe<Int>;
  range_in?: Maybe<Int[] | Int>;
  range_not_in?: Maybe<Int[] | Int>;
  range_lt?: Maybe<Int>;
  range_lte?: Maybe<Int>;
  range_gt?: Maybe<Int>;
  range_gte?: Maybe<Int>;
  rangedCombar?: Maybe<Int>;
  rangedCombar_not?: Maybe<Int>;
  rangedCombar_in?: Maybe<Int[] | Int>;
  rangedCombar_not_in?: Maybe<Int[] | Int>;
  rangedCombar_lt?: Maybe<Int>;
  rangedCombar_lte?: Maybe<Int>;
  rangedCombar_gt?: Maybe<Int>;
  rangedCombar_gte?: Maybe<Int>;
  bombard?: Maybe<Int>;
  bombard_not?: Maybe<Int>;
  bombard_in?: Maybe<Int[] | Int>;
  bombard_not_in?: Maybe<Int[] | Int>;
  bombard_lt?: Maybe<Int>;
  bombard_lte?: Maybe<Int>;
  bombard_gt?: Maybe<Int>;
  bombard_gte?: Maybe<Int>;
  AND?: Maybe<UnitScalarWhereInput[] | UnitScalarWhereInput>;
  OR?: Maybe<UnitScalarWhereInput[] | UnitScalarWhereInput>;
  NOT?: Maybe<UnitScalarWhereInput[] | UnitScalarWhereInput>;
}

export interface UnitUpdateManyWithWhereNestedInput {
  where: UnitScalarWhereInput;
  data: UnitUpdateManyDataInput;
}

export interface UnitUpdateManyDataInput {
  type?: Maybe<Int>;
  cost?: Maybe<Int>;
  baseMoves?: Maybe<Int>;
  combat?: Maybe<Int>;
  range?: Maybe<Int>;
  rangedCombar?: Maybe<Int>;
  bombard?: Maybe<Int>;
}

export interface LeaderUpsertWithWhereUniqueNestedInput {
  where: LeaderWhereUniqueInput;
  update: LeaderUpdateDataInput;
  create: LeaderCreateInput;
}

export interface LeaderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<LeaderScalarWhereInput[] | LeaderScalarWhereInput>;
  OR?: Maybe<LeaderScalarWhereInput[] | LeaderScalarWhereInput>;
  NOT?: Maybe<LeaderScalarWhereInput[] | LeaderScalarWhereInput>;
}

export interface LeaderUpdateManyWithWhereNestedInput {
  where: LeaderScalarWhereInput;
  data: LeaderUpdateManyDataInput;
}

export interface LeaderUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface MapUpdateOneRequiredInput {
  create?: Maybe<MapCreateInput>;
  update?: Maybe<MapUpdateDataInput>;
  upsert?: Maybe<MapUpsertNestedInput>;
  connect?: Maybe<MapWhereUniqueInput>;
}

export interface MapUpdateDataInput {
  type?: Maybe<String>;
  tiles?: Maybe<TileUpdateManyInput>;
}

export interface TileUpdateManyInput {
  create?: Maybe<TileCreateInput[] | TileCreateInput>;
  update?: Maybe<
    | TileUpdateWithWhereUniqueNestedInput[]
    | TileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | TileUpsertWithWhereUniqueNestedInput[]
    | TileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TileWhereUniqueInput[] | TileWhereUniqueInput>;
  connect?: Maybe<TileWhereUniqueInput[] | TileWhereUniqueInput>;
  set?: Maybe<TileWhereUniqueInput[] | TileWhereUniqueInput>;
  disconnect?: Maybe<TileWhereUniqueInput[] | TileWhereUniqueInput>;
  deleteMany?: Maybe<TileScalarWhereInput[] | TileScalarWhereInput>;
  updateMany?: Maybe<
    TileUpdateManyWithWhereNestedInput[] | TileUpdateManyWithWhereNestedInput
  >;
}

export interface TileUpdateWithWhereUniqueNestedInput {
  where: TileWhereUniqueInput;
  data: TileUpdateDataInput;
}

export interface TileUpdateDataInput {
  location?: Maybe<TileUpdatelocationInput>;
  terrain?: Maybe<IntTSUpdateManyInput>;
  feature?: Maybe<IntTSUpdateManyInput>;
}

export interface TileUpdatelocationInput {
  set?: Maybe<Int[] | Int>;
}

export interface TileUpsertWithWhereUniqueNestedInput {
  where: TileWhereUniqueInput;
  update: TileUpdateDataInput;
  create: TileCreateInput;
}

export interface TileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<TileScalarWhereInput[] | TileScalarWhereInput>;
  OR?: Maybe<TileScalarWhereInput[] | TileScalarWhereInput>;
  NOT?: Maybe<TileScalarWhereInput[] | TileScalarWhereInput>;
}

export interface TileUpdateManyWithWhereNestedInput {
  where: TileScalarWhereInput;
  data: TileUpdateManyDataInput;
}

export interface TileUpdateManyDataInput {
  location?: Maybe<TileUpdatelocationInput>;
}

export interface MapUpsertNestedInput {
  update: MapUpdateDataInput;
  create: MapCreateInput;
}

export interface GameUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface LeaderUpdateInput {
  name?: Maybe<String>;
  player?: Maybe<PlayerUpdateOneRequiredInput>;
  cities?: Maybe<CityUpdateManyInput>;
  techs?: Maybe<TechUpdateManyInput>;
  civics?: Maybe<CivicUpdateManyInput>;
  units?: Maybe<UnitUpdateManyInput>;
}

export interface LeaderUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface MapUpdateInput {
  type?: Maybe<String>;
  tiles?: Maybe<TileUpdateManyInput>;
}

export interface MapUpdateManyMutationInput {
  type?: Maybe<String>;
}

export interface PlayerUpdateInput {
  name?: Maybe<StringTSUpdateManyInput>;
  isHuman?: Maybe<BooleanTSUpdateManyInput>;
}

export interface TechUpdateInput {
  type?: Maybe<Int>;
  progress?: Maybe<FloatTSUpdateManyInput>;
  boosted?: Maybe<BooleanTSUpdateManyInput>;
  cost?: Maybe<Int>;
}

export interface TechUpdateManyMutationInput {
  type?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface TileUpdateInput {
  location?: Maybe<TileUpdatelocationInput>;
  terrain?: Maybe<IntTSUpdateManyInput>;
  feature?: Maybe<IntTSUpdateManyInput>;
}

export interface TileUpdateManyMutationInput {
  location?: Maybe<TileUpdatelocationInput>;
}

export interface UnitUpdateInput {
  type?: Maybe<Int>;
  location?: Maybe<TileTSUpdateManyInput>;
  cost?: Maybe<Int>;
  baseMoves?: Maybe<Int>;
  combat?: Maybe<Int>;
  range?: Maybe<Int>;
  rangedCombar?: Maybe<Int>;
  bombard?: Maybe<Int>;
}

export interface UnitUpdateManyMutationInput {
  type?: Maybe<Int>;
  cost?: Maybe<Int>;
  baseMoves?: Maybe<Int>;
  combat?: Maybe<Int>;
  range?: Maybe<Int>;
  rangedCombar?: Maybe<Int>;
  bombard?: Maybe<Int>;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CityWhereInput>;
  AND?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
}

export interface CivicSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CivicWhereInput>;
  AND?: Maybe<CivicSubscriptionWhereInput[] | CivicSubscriptionWhereInput>;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GameWhereInput>;
  AND?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
}

export interface LeaderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LeaderWhereInput>;
  AND?: Maybe<LeaderSubscriptionWhereInput[] | LeaderSubscriptionWhereInput>;
}

export interface MapSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MapWhereInput>;
  AND?: Maybe<MapSubscriptionWhereInput[] | MapSubscriptionWhereInput>;
}

export interface PlayerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlayerWhereInput>;
  AND?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
}

export interface TechSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TechWhereInput>;
  AND?: Maybe<TechSubscriptionWhereInput[] | TechSubscriptionWhereInput>;
}

export interface TileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TileWhereInput>;
  AND?: Maybe<TileSubscriptionWhereInput[] | TileSubscriptionWhereInput>;
}

export interface UnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UnitWhereInput>;
  AND?: Maybe<UnitSubscriptionWhereInput[] | UnitSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface City {
  id: ID_Output;
  name?: <T = FragmentableArray<StringTS>>() => T;
  isExist?: <T = FragmentableArray<BooleanTS>>() => T;
  population?: <T = FragmentableArray<IntTS>>() => T;
  amenity?: <T = FragmentableArray<IntTS>>() => T;
  entertainment?: <T = FragmentableArray<IntTS>>() => T;
  location?: <T = FragmentableArray<TileTS>>() => T;
}

export interface CityPromise extends Promise<City>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: <T = FragmentableArray<StringTS>>() => T;
  isExist: <T = FragmentableArray<BooleanTS>>() => T;
  population: <T = FragmentableArray<IntTS>>() => T;
  amenity: <T = FragmentableArray<IntTS>>() => T;
  entertainment: <T = FragmentableArray<IntTS>>() => T;
  location: <T = FragmentableArray<TileTS>>() => T;
}

export interface CitySubscription
  extends Promise<AsyncIterator<City>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: <T = Promise<AsyncIterator<StringTSSubscription>>>() => T;
  isExist: <T = Promise<AsyncIterator<BooleanTSSubscription>>>() => T;
  population: <T = Promise<AsyncIterator<IntTSSubscription>>>() => T;
  amenity: <T = Promise<AsyncIterator<IntTSSubscription>>>() => T;
  entertainment: <T = Promise<AsyncIterator<IntTSSubscription>>>() => T;
  location: <T = Promise<AsyncIterator<TileTSSubscription>>>() => T;
}

export interface CityNullablePromise
  extends Promise<City | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: <T = FragmentableArray<StringTS>>() => T;
  isExist: <T = FragmentableArray<BooleanTS>>() => T;
  population: <T = FragmentableArray<IntTS>>() => T;
  amenity: <T = FragmentableArray<IntTS>>() => T;
  entertainment: <T = FragmentableArray<IntTS>>() => T;
  location: <T = FragmentableArray<TileTS>>() => T;
}

export interface StringTS {
  value: String;
  time: DateTimeOutput;
}

export interface StringTSPromise extends Promise<StringTS>, Fragmentable {
  value: () => Promise<String>;
  time: () => Promise<DateTimeOutput>;
}

export interface StringTSSubscription
  extends Promise<AsyncIterator<StringTS>>,
    Fragmentable {
  value: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StringTSNullablePromise
  extends Promise<StringTS | null>,
    Fragmentable {
  value: () => Promise<String>;
  time: () => Promise<DateTimeOutput>;
}

export interface BooleanTS {
  value: Boolean;
  time: DateTimeOutput;
}

export interface BooleanTSPromise extends Promise<BooleanTS>, Fragmentable {
  value: () => Promise<Boolean>;
  time: () => Promise<DateTimeOutput>;
}

export interface BooleanTSSubscription
  extends Promise<AsyncIterator<BooleanTS>>,
    Fragmentable {
  value: () => Promise<AsyncIterator<Boolean>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BooleanTSNullablePromise
  extends Promise<BooleanTS | null>,
    Fragmentable {
  value: () => Promise<Boolean>;
  time: () => Promise<DateTimeOutput>;
}

export interface IntTS {
  value: Int;
  time: DateTimeOutput;
}

export interface IntTSPromise extends Promise<IntTS>, Fragmentable {
  value: () => Promise<Int>;
  time: () => Promise<DateTimeOutput>;
}

export interface IntTSSubscription
  extends Promise<AsyncIterator<IntTS>>,
    Fragmentable {
  value: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface IntTSNullablePromise
  extends Promise<IntTS | null>,
    Fragmentable {
  value: () => Promise<Int>;
  time: () => Promise<DateTimeOutput>;
}

export interface TileTS {
  time: DateTimeOutput;
}

export interface TileTSPromise extends Promise<TileTS>, Fragmentable {
  value: <T = TilePromise>() => T;
  time: () => Promise<DateTimeOutput>;
}

export interface TileTSSubscription
  extends Promise<AsyncIterator<TileTS>>,
    Fragmentable {
  value: <T = TileSubscription>() => T;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TileTSNullablePromise
  extends Promise<TileTS | null>,
    Fragmentable {
  value: <T = TilePromise>() => T;
  time: () => Promise<DateTimeOutput>;
}

export interface Tile {
  id: ID_Output;
  location: Int[];
  terrain?: <T = FragmentableArray<IntTS>>() => T;
  feature?: <T = FragmentableArray<IntTS>>() => T;
}

export interface TilePromise extends Promise<Tile>, Fragmentable {
  id: () => Promise<ID_Output>;
  location: () => Promise<Int[]>;
  terrain: <T = FragmentableArray<IntTS>>() => T;
  feature: <T = FragmentableArray<IntTS>>() => T;
}

export interface TileSubscription
  extends Promise<AsyncIterator<Tile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  location: () => Promise<AsyncIterator<Int[]>>;
  terrain: <T = Promise<AsyncIterator<IntTSSubscription>>>() => T;
  feature: <T = Promise<AsyncIterator<IntTSSubscription>>>() => T;
}

export interface TileNullablePromise
  extends Promise<Tile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  location: () => Promise<Int[]>;
  terrain: <T = FragmentableArray<IntTS>>() => T;
  feature: <T = FragmentableArray<IntTS>>() => T;
}

export interface CityConnection {
  pageInfo: PageInfo;
  edges: CityEdge[];
}

export interface CityConnectionPromise
  extends Promise<CityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CityEdge>>() => T;
  aggregate: <T = AggregateCityPromise>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CityEdge {
  node: City;
  cursor: String;
}

export interface CityEdgePromise extends Promise<CityEdge>, Fragmentable {
  node: <T = CityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdge>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCity {
  count: Int;
}

export interface AggregateCityPromise
  extends Promise<AggregateCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Civic {
  id: ID_Output;
  type: Int;
  progress?: <T = FragmentableArray<FloatTS>>() => T;
  boosted?: <T = FragmentableArray<BooleanTS>>() => T;
  cost: Int;
}

export interface CivicPromise extends Promise<Civic>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  progress: <T = FragmentableArray<FloatTS>>() => T;
  boosted: <T = FragmentableArray<BooleanTS>>() => T;
  cost: () => Promise<Int>;
}

export interface CivicSubscription
  extends Promise<AsyncIterator<Civic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<Int>>;
  progress: <T = Promise<AsyncIterator<FloatTSSubscription>>>() => T;
  boosted: <T = Promise<AsyncIterator<BooleanTSSubscription>>>() => T;
  cost: () => Promise<AsyncIterator<Int>>;
}

export interface CivicNullablePromise
  extends Promise<Civic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  progress: <T = FragmentableArray<FloatTS>>() => T;
  boosted: <T = FragmentableArray<BooleanTS>>() => T;
  cost: () => Promise<Int>;
}

export interface FloatTS {
  value: Float;
  time: DateTimeOutput;
}

export interface FloatTSPromise extends Promise<FloatTS>, Fragmentable {
  value: () => Promise<Float>;
  time: () => Promise<DateTimeOutput>;
}

export interface FloatTSSubscription
  extends Promise<AsyncIterator<FloatTS>>,
    Fragmentable {
  value: () => Promise<AsyncIterator<Float>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FloatTSNullablePromise
  extends Promise<FloatTS | null>,
    Fragmentable {
  value: () => Promise<Float>;
  time: () => Promise<DateTimeOutput>;
}

export interface CivicConnection {
  pageInfo: PageInfo;
  edges: CivicEdge[];
}

export interface CivicConnectionPromise
  extends Promise<CivicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CivicEdge>>() => T;
  aggregate: <T = AggregateCivicPromise>() => T;
}

export interface CivicConnectionSubscription
  extends Promise<AsyncIterator<CivicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CivicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCivicSubscription>() => T;
}

export interface CivicEdge {
  node: Civic;
  cursor: String;
}

export interface CivicEdgePromise extends Promise<CivicEdge>, Fragmentable {
  node: <T = CivicPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CivicEdgeSubscription
  extends Promise<AsyncIterator<CivicEdge>>,
    Fragmentable {
  node: <T = CivicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCivic {
  count: Int;
}

export interface AggregateCivicPromise
  extends Promise<AggregateCivic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCivicSubscription
  extends Promise<AsyncIterator<AggregateCivic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Game {
  id: ID_Output;
  name: String;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  leaders: <T = FragmentableArray<Leader>>(args?: {
    where?: LeaderWhereInput;
    orderBy?: LeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  map: <T = MapPromise>() => T;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  leaders: <T = Promise<AsyncIterator<LeaderSubscription>>>(args?: {
    where?: LeaderWhereInput;
    orderBy?: LeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  map: <T = MapSubscription>() => T;
}

export interface GameNullablePromise
  extends Promise<Game | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  leaders: <T = FragmentableArray<Leader>>(args?: {
    where?: LeaderWhereInput;
    orderBy?: LeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  map: <T = MapPromise>() => T;
}

export interface Leader {
  id: ID_Output;
  name: String;
}

export interface LeaderPromise extends Promise<Leader>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  player: <T = PlayerPromise>() => T;
  cities: <T = FragmentableArray<City>>(args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  techs: <T = FragmentableArray<Tech>>(args?: {
    where?: TechWhereInput;
    orderBy?: TechOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  civics: <T = FragmentableArray<Civic>>(args?: {
    where?: CivicWhereInput;
    orderBy?: CivicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  units: <T = FragmentableArray<Unit>>(args?: {
    where?: UnitWhereInput;
    orderBy?: UnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LeaderSubscription
  extends Promise<AsyncIterator<Leader>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  player: <T = PlayerSubscription>() => T;
  cities: <T = Promise<AsyncIterator<CitySubscription>>>(args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  techs: <T = Promise<AsyncIterator<TechSubscription>>>(args?: {
    where?: TechWhereInput;
    orderBy?: TechOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  civics: <T = Promise<AsyncIterator<CivicSubscription>>>(args?: {
    where?: CivicWhereInput;
    orderBy?: CivicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  units: <T = Promise<AsyncIterator<UnitSubscription>>>(args?: {
    where?: UnitWhereInput;
    orderBy?: UnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LeaderNullablePromise
  extends Promise<Leader | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  player: <T = PlayerPromise>() => T;
  cities: <T = FragmentableArray<City>>(args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  techs: <T = FragmentableArray<Tech>>(args?: {
    where?: TechWhereInput;
    orderBy?: TechOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  civics: <T = FragmentableArray<Civic>>(args?: {
    where?: CivicWhereInput;
    orderBy?: CivicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  units: <T = FragmentableArray<Unit>>(args?: {
    where?: UnitWhereInput;
    orderBy?: UnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Player {
  id: ID_Output;
  name?: <T = FragmentableArray<StringTS>>() => T;
  isHuman?: <T = FragmentableArray<BooleanTS>>() => T;
}

export interface PlayerPromise extends Promise<Player>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: <T = FragmentableArray<StringTS>>() => T;
  isHuman: <T = FragmentableArray<BooleanTS>>() => T;
}

export interface PlayerSubscription
  extends Promise<AsyncIterator<Player>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: <T = Promise<AsyncIterator<StringTSSubscription>>>() => T;
  isHuman: <T = Promise<AsyncIterator<BooleanTSSubscription>>>() => T;
}

export interface PlayerNullablePromise
  extends Promise<Player | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: <T = FragmentableArray<StringTS>>() => T;
  isHuman: <T = FragmentableArray<BooleanTS>>() => T;
}

export interface Tech {
  id: ID_Output;
  type: Int;
  progress?: <T = FragmentableArray<FloatTS>>() => T;
  boosted?: <T = FragmentableArray<BooleanTS>>() => T;
  cost: Int;
}

export interface TechPromise extends Promise<Tech>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  progress: <T = FragmentableArray<FloatTS>>() => T;
  boosted: <T = FragmentableArray<BooleanTS>>() => T;
  cost: () => Promise<Int>;
}

export interface TechSubscription
  extends Promise<AsyncIterator<Tech>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<Int>>;
  progress: <T = Promise<AsyncIterator<FloatTSSubscription>>>() => T;
  boosted: <T = Promise<AsyncIterator<BooleanTSSubscription>>>() => T;
  cost: () => Promise<AsyncIterator<Int>>;
}

export interface TechNullablePromise
  extends Promise<Tech | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  progress: <T = FragmentableArray<FloatTS>>() => T;
  boosted: <T = FragmentableArray<BooleanTS>>() => T;
  cost: () => Promise<Int>;
}

export interface Unit {
  id: ID_Output;
  type: Int;
  location?: <T = FragmentableArray<TileTS>>() => T;
  cost: Int;
  baseMoves?: Int;
  combat?: Int;
  range?: Int;
  rangedCombar?: Int;
  bombard?: Int;
}

export interface UnitPromise extends Promise<Unit>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  location: <T = FragmentableArray<TileTS>>() => T;
  cost: () => Promise<Int>;
  baseMoves: () => Promise<Int>;
  combat: () => Promise<Int>;
  range: () => Promise<Int>;
  rangedCombar: () => Promise<Int>;
  bombard: () => Promise<Int>;
}

export interface UnitSubscription
  extends Promise<AsyncIterator<Unit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<Int>>;
  location: <T = Promise<AsyncIterator<TileTSSubscription>>>() => T;
  cost: () => Promise<AsyncIterator<Int>>;
  baseMoves: () => Promise<AsyncIterator<Int>>;
  combat: () => Promise<AsyncIterator<Int>>;
  range: () => Promise<AsyncIterator<Int>>;
  rangedCombar: () => Promise<AsyncIterator<Int>>;
  bombard: () => Promise<AsyncIterator<Int>>;
}

export interface UnitNullablePromise
  extends Promise<Unit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  location: <T = FragmentableArray<TileTS>>() => T;
  cost: () => Promise<Int>;
  baseMoves: () => Promise<Int>;
  combat: () => Promise<Int>;
  range: () => Promise<Int>;
  rangedCombar: () => Promise<Int>;
  bombard: () => Promise<Int>;
}

export interface Map {
  id: ID_Output;
  type: String;
}

export interface MapPromise extends Promise<Map>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  tiles: <T = FragmentableArray<Tile>>(args?: {
    where?: TileWhereInput;
    orderBy?: TileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MapSubscription
  extends Promise<AsyncIterator<Map>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  tiles: <T = Promise<AsyncIterator<TileSubscription>>>(args?: {
    where?: TileWhereInput;
    orderBy?: TileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MapNullablePromise extends Promise<Map | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  tiles: <T = FragmentableArray<Tile>>(args?: {
    where?: TileWhereInput;
    orderBy?: TileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LeaderConnection {
  pageInfo: PageInfo;
  edges: LeaderEdge[];
}

export interface LeaderConnectionPromise
  extends Promise<LeaderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LeaderEdge>>() => T;
  aggregate: <T = AggregateLeaderPromise>() => T;
}

export interface LeaderConnectionSubscription
  extends Promise<AsyncIterator<LeaderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LeaderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLeaderSubscription>() => T;
}

export interface LeaderEdge {
  node: Leader;
  cursor: String;
}

export interface LeaderEdgePromise extends Promise<LeaderEdge>, Fragmentable {
  node: <T = LeaderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LeaderEdgeSubscription
  extends Promise<AsyncIterator<LeaderEdge>>,
    Fragmentable {
  node: <T = LeaderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLeader {
  count: Int;
}

export interface AggregateLeaderPromise
  extends Promise<AggregateLeader>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLeaderSubscription
  extends Promise<AsyncIterator<AggregateLeader>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MapConnection {
  pageInfo: PageInfo;
  edges: MapEdge[];
}

export interface MapConnectionPromise
  extends Promise<MapConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MapEdge>>() => T;
  aggregate: <T = AggregateMapPromise>() => T;
}

export interface MapConnectionSubscription
  extends Promise<AsyncIterator<MapConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MapEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMapSubscription>() => T;
}

export interface MapEdge {
  node: Map;
  cursor: String;
}

export interface MapEdgePromise extends Promise<MapEdge>, Fragmentable {
  node: <T = MapPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MapEdgeSubscription
  extends Promise<AsyncIterator<MapEdge>>,
    Fragmentable {
  node: <T = MapSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMap {
  count: Int;
}

export interface AggregateMapPromise
  extends Promise<AggregateMap>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMapSubscription
  extends Promise<AsyncIterator<AggregateMap>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlayerConnection {
  pageInfo: PageInfo;
  edges: PlayerEdge[];
}

export interface PlayerConnectionPromise
  extends Promise<PlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlayerEdge>>() => T;
  aggregate: <T = AggregatePlayerPromise>() => T;
}

export interface PlayerConnectionSubscription
  extends Promise<AsyncIterator<PlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlayerSubscription>() => T;
}

export interface PlayerEdge {
  node: Player;
  cursor: String;
}

export interface PlayerEdgePromise extends Promise<PlayerEdge>, Fragmentable {
  node: <T = PlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlayerEdgeSubscription
  extends Promise<AsyncIterator<PlayerEdge>>,
    Fragmentable {
  node: <T = PlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlayer {
  count: Int;
}

export interface AggregatePlayerPromise
  extends Promise<AggregatePlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlayerSubscription
  extends Promise<AsyncIterator<AggregatePlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TechConnection {
  pageInfo: PageInfo;
  edges: TechEdge[];
}

export interface TechConnectionPromise
  extends Promise<TechConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TechEdge>>() => T;
  aggregate: <T = AggregateTechPromise>() => T;
}

export interface TechConnectionSubscription
  extends Promise<AsyncIterator<TechConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TechEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTechSubscription>() => T;
}

export interface TechEdge {
  node: Tech;
  cursor: String;
}

export interface TechEdgePromise extends Promise<TechEdge>, Fragmentable {
  node: <T = TechPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TechEdgeSubscription
  extends Promise<AsyncIterator<TechEdge>>,
    Fragmentable {
  node: <T = TechSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTech {
  count: Int;
}

export interface AggregateTechPromise
  extends Promise<AggregateTech>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTechSubscription
  extends Promise<AsyncIterator<AggregateTech>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TileConnection {
  pageInfo: PageInfo;
  edges: TileEdge[];
}

export interface TileConnectionPromise
  extends Promise<TileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TileEdge>>() => T;
  aggregate: <T = AggregateTilePromise>() => T;
}

export interface TileConnectionSubscription
  extends Promise<AsyncIterator<TileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTileSubscription>() => T;
}

export interface TileEdge {
  node: Tile;
  cursor: String;
}

export interface TileEdgePromise extends Promise<TileEdge>, Fragmentable {
  node: <T = TilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TileEdgeSubscription
  extends Promise<AsyncIterator<TileEdge>>,
    Fragmentable {
  node: <T = TileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTile {
  count: Int;
}

export interface AggregateTilePromise
  extends Promise<AggregateTile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTileSubscription
  extends Promise<AsyncIterator<AggregateTile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UnitConnection {
  pageInfo: PageInfo;
  edges: UnitEdge[];
}

export interface UnitConnectionPromise
  extends Promise<UnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UnitEdge>>() => T;
  aggregate: <T = AggregateUnitPromise>() => T;
}

export interface UnitConnectionSubscription
  extends Promise<AsyncIterator<UnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUnitSubscription>() => T;
}

export interface UnitEdge {
  node: Unit;
  cursor: String;
}

export interface UnitEdgePromise extends Promise<UnitEdge>, Fragmentable {
  node: <T = UnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UnitEdgeSubscription
  extends Promise<AsyncIterator<UnitEdge>>,
    Fragmentable {
  node: <T = UnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUnit {
  count: Int;
}

export interface AggregateUnitPromise
  extends Promise<AggregateUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUnitSubscription
  extends Promise<AsyncIterator<AggregateUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CitySubscriptionPayload {
  mutation: MutationType;
  node: City;
  updatedFields: String[];
  previousValues: CityPreviousValues;
}

export interface CitySubscriptionPayloadPromise
  extends Promise<CitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValuesPromise>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface CityPreviousValues {
  id: ID_Output;
}

export interface CityPreviousValuesPromise
  extends Promise<CityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface CivicSubscriptionPayload {
  mutation: MutationType;
  node: Civic;
  updatedFields: String[];
  previousValues: CivicPreviousValues;
}

export interface CivicSubscriptionPayloadPromise
  extends Promise<CivicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CivicPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CivicPreviousValuesPromise>() => T;
}

export interface CivicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CivicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CivicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CivicPreviousValuesSubscription>() => T;
}

export interface CivicPreviousValues {
  id: ID_Output;
  type: Int;
  cost: Int;
}

export interface CivicPreviousValuesPromise
  extends Promise<CivicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  cost: () => Promise<Int>;
}

export interface CivicPreviousValuesSubscription
  extends Promise<AsyncIterator<CivicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<Int>>;
  cost: () => Promise<AsyncIterator<Int>>;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface GamePreviousValues {
  id: ID_Output;
  name: String;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface LeaderSubscriptionPayload {
  mutation: MutationType;
  node: Leader;
  updatedFields: String[];
  previousValues: LeaderPreviousValues;
}

export interface LeaderSubscriptionPayloadPromise
  extends Promise<LeaderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LeaderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LeaderPreviousValuesPromise>() => T;
}

export interface LeaderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LeaderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LeaderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LeaderPreviousValuesSubscription>() => T;
}

export interface LeaderPreviousValues {
  id: ID_Output;
  name: String;
}

export interface LeaderPreviousValuesPromise
  extends Promise<LeaderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface LeaderPreviousValuesSubscription
  extends Promise<AsyncIterator<LeaderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface MapSubscriptionPayload {
  mutation: MutationType;
  node: Map;
  updatedFields: String[];
  previousValues: MapPreviousValues;
}

export interface MapSubscriptionPayloadPromise
  extends Promise<MapSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MapPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MapPreviousValuesPromise>() => T;
}

export interface MapSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MapSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MapSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MapPreviousValuesSubscription>() => T;
}

export interface MapPreviousValues {
  id: ID_Output;
  type: String;
}

export interface MapPreviousValuesPromise
  extends Promise<MapPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
}

export interface MapPreviousValuesSubscription
  extends Promise<AsyncIterator<MapPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface PlayerSubscriptionPayload {
  mutation: MutationType;
  node: Player;
  updatedFields: String[];
  previousValues: PlayerPreviousValues;
}

export interface PlayerSubscriptionPayloadPromise
  extends Promise<PlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlayerPreviousValuesPromise>() => T;
}

export interface PlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlayerPreviousValuesSubscription>() => T;
}

export interface PlayerPreviousValues {
  id: ID_Output;
}

export interface PlayerPreviousValuesPromise
  extends Promise<PlayerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<PlayerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TechSubscriptionPayload {
  mutation: MutationType;
  node: Tech;
  updatedFields: String[];
  previousValues: TechPreviousValues;
}

export interface TechSubscriptionPayloadPromise
  extends Promise<TechSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TechPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TechPreviousValuesPromise>() => T;
}

export interface TechSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TechSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TechSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TechPreviousValuesSubscription>() => T;
}

export interface TechPreviousValues {
  id: ID_Output;
  type: Int;
  cost: Int;
}

export interface TechPreviousValuesPromise
  extends Promise<TechPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  cost: () => Promise<Int>;
}

export interface TechPreviousValuesSubscription
  extends Promise<AsyncIterator<TechPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<Int>>;
  cost: () => Promise<AsyncIterator<Int>>;
}

export interface TileSubscriptionPayload {
  mutation: MutationType;
  node: Tile;
  updatedFields: String[];
  previousValues: TilePreviousValues;
}

export interface TileSubscriptionPayloadPromise
  extends Promise<TileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TilePreviousValuesPromise>() => T;
}

export interface TileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TilePreviousValuesSubscription>() => T;
}

export interface TilePreviousValues {
  id: ID_Output;
  location: Int[];
}

export interface TilePreviousValuesPromise
  extends Promise<TilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  location: () => Promise<Int[]>;
}

export interface TilePreviousValuesSubscription
  extends Promise<AsyncIterator<TilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  location: () => Promise<AsyncIterator<Int[]>>;
}

export interface UnitSubscriptionPayload {
  mutation: MutationType;
  node: Unit;
  updatedFields: String[];
  previousValues: UnitPreviousValues;
}

export interface UnitSubscriptionPayloadPromise
  extends Promise<UnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UnitPreviousValuesPromise>() => T;
}

export interface UnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UnitPreviousValuesSubscription>() => T;
}

export interface UnitPreviousValues {
  id: ID_Output;
  type: Int;
  cost: Int;
  baseMoves?: Int;
  combat?: Int;
  range?: Int;
  rangedCombar?: Int;
  bombard?: Int;
}

export interface UnitPreviousValuesPromise
  extends Promise<UnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<Int>;
  cost: () => Promise<Int>;
  baseMoves: () => Promise<Int>;
  combat: () => Promise<Int>;
  range: () => Promise<Int>;
  rangedCombar: () => Promise<Int>;
  bombard: () => Promise<Int>;
}

export interface UnitPreviousValuesSubscription
  extends Promise<AsyncIterator<UnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<Int>>;
  cost: () => Promise<AsyncIterator<Int>>;
  baseMoves: () => Promise<AsyncIterator<Int>>;
  combat: () => Promise<AsyncIterator<Int>>;
  range: () => Promise<AsyncIterator<Int>>;
  rangedCombar: () => Promise<AsyncIterator<Int>>;
  bombard: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Game",
    embedded: false
  },
  {
    name: "Leader",
    embedded: false
  },
  {
    name: "Player",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "Unit",
    embedded: false
  },
  {
    name: "Tech",
    embedded: false
  },
  {
    name: "Civic",
    embedded: false
  },
  {
    name: "Map",
    embedded: false
  },
  {
    name: "Tile",
    embedded: false
  },
  {
    name: "IntTS",
    embedded: true
  },
  {
    name: "TileTS",
    embedded: true
  },
  {
    name: "FloatTS",
    embedded: true
  },
  {
    name: "BooleanTS",
    embedded: true
  },
  {
    name: "StringTS",
    embedded: true
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
