// Code generated by Prisma (prisma@1.35.0-beta). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCity {
  count: Int!
}

type AggregateCivic {
  count: Int!
}

type AggregateGame {
  count: Int!
}

type AggregateLeader {
  count: Int!
}

type AggregateMap {
  count: Int!
}

type AggregatePlayer {
  count: Int!
}

type AggregateTech {
  count: Int!
}

type AggregateTile {
  count: Int!
}

type AggregateUnit {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type BooleanTS {
  value: Boolean!
  time: DateTime!
}

input BooleanTSCreateInput {
  value: Boolean!
}

input BooleanTSCreateManyInput {
  create: [BooleanTSCreateInput!]
}

input BooleanTSRestrictedWhereInput {
  value: Boolean
  value_not: Boolean
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [BooleanTSRestrictedWhereInput!]
}

input BooleanTSScalarWhereInput {
  value: Boolean
  value_not: Boolean
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [BooleanTSScalarWhereInput!]
  OR: [BooleanTSScalarWhereInput!]
  NOT: [BooleanTSScalarWhereInput!]
}

input BooleanTSUpdateManyDataInput {
  value: Boolean
}

input BooleanTSUpdateManyInput {
  create: [BooleanTSCreateInput!]
  deleteMany: [BooleanTSScalarWhereInput!]
  updateMany: [BooleanTSUpdateManyWithWhereNestedInput!]
}

input BooleanTSUpdateManyWithWhereNestedInput {
  where: BooleanTSScalarWhereInput!
  data: BooleanTSUpdateManyDataInput!
}

input BooleanTSWhereInput {
  value: Boolean
  value_not: Boolean
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [BooleanTSWhereInput!]
}

type City {
  id: ID!
  name: [StringTS!]
  isExist: [BooleanTS!]
  population: [IntTS!]
  amenity: [IntTS!]
  entertainment: [IntTS!]
  location: [TileTS!]
}

type CityConnection {
  pageInfo: PageInfo!
  edges: [CityEdge]!
  aggregate: AggregateCity!
}

input CityCreateInput {
  id: ID
  name: StringTSCreateManyInput
  isExist: BooleanTSCreateManyInput
  population: IntTSCreateManyInput
  amenity: IntTSCreateManyInput
  entertainment: IntTSCreateManyInput
  location: TileTSCreateManyInput
}

input CityCreateManyInput {
  create: [CityCreateInput!]
  connect: [CityWhereUniqueInput!]
}

type CityEdge {
  node: City!
  cursor: String!
}

enum CityOrderByInput {
  id_ASC
  id_DESC
}

type CityPreviousValues {
  id: ID!
}

input CityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [CityScalarWhereInput!]
  OR: [CityScalarWhereInput!]
  NOT: [CityScalarWhereInput!]
}

type CitySubscriptionPayload {
  mutation: MutationType!
  node: City
  updatedFields: [String!]
  previousValues: CityPreviousValues
}

input CitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CityWhereInput
  AND: [CitySubscriptionWhereInput!]
}

input CityUpdateDataInput {
  name: StringTSUpdateManyInput
  isExist: BooleanTSUpdateManyInput
  population: IntTSUpdateManyInput
  amenity: IntTSUpdateManyInput
  entertainment: IntTSUpdateManyInput
  location: TileTSUpdateManyInput
}

input CityUpdateInput {
  name: StringTSUpdateManyInput
  isExist: BooleanTSUpdateManyInput
  population: IntTSUpdateManyInput
  amenity: IntTSUpdateManyInput
  entertainment: IntTSUpdateManyInput
  location: TileTSUpdateManyInput
}

input CityUpdateManyInput {
  create: [CityCreateInput!]
  update: [CityUpdateWithWhereUniqueNestedInput!]
  upsert: [CityUpsertWithWhereUniqueNestedInput!]
  delete: [CityWhereUniqueInput!]
  connect: [CityWhereUniqueInput!]
  set: [CityWhereUniqueInput!]
  disconnect: [CityWhereUniqueInput!]
  deleteMany: [CityScalarWhereInput!]
}

input CityUpdateWithWhereUniqueNestedInput {
  where: CityWhereUniqueInput!
  data: CityUpdateDataInput!
}

input CityUpsertWithWhereUniqueNestedInput {
  where: CityWhereUniqueInput!
  update: CityUpdateDataInput!
  create: CityCreateInput!
}

input CityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name_some: StringTSWhereInput
  name_every: StringTSRestrictedWhereInput
  name_none: StringTSRestrictedWhereInput
  isExist_some: BooleanTSWhereInput
  isExist_every: BooleanTSRestrictedWhereInput
  isExist_none: BooleanTSRestrictedWhereInput
  population_some: IntTSWhereInput
  population_every: IntTSRestrictedWhereInput
  population_none: IntTSRestrictedWhereInput
  amenity_some: IntTSWhereInput
  amenity_every: IntTSRestrictedWhereInput
  amenity_none: IntTSRestrictedWhereInput
  entertainment_some: IntTSWhereInput
  entertainment_every: IntTSRestrictedWhereInput
  entertainment_none: IntTSRestrictedWhereInput
  location_some: TileTSWhereInput
  location_every: TileTSRestrictedWhereInput
  location_none: TileTSRestrictedWhereInput
  AND: [CityWhereInput!]
}

input CityWhereUniqueInput {
  id: ID
}

type Civic {
  id: ID!
  type: Int!
  progress: [FloatTS!]
  boosted: [BooleanTS!]
  cost: Int!
}

type CivicConnection {
  pageInfo: PageInfo!
  edges: [CivicEdge]!
  aggregate: AggregateCivic!
}

input CivicCreateInput {
  id: ID
  type: Int!
  progress: FloatTSCreateManyInput
  boosted: BooleanTSCreateManyInput
  cost: Int!
}

input CivicCreateManyInput {
  create: [CivicCreateInput!]
  connect: [CivicWhereUniqueInput!]
}

type CivicEdge {
  node: Civic!
  cursor: String!
}

enum CivicOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  cost_ASC
  cost_DESC
}

type CivicPreviousValues {
  id: ID!
  type: Int!
  cost: Int!
}

input CivicScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: Int
  type_not: Int
  type_in: [Int!]
  type_not_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_gt: Int
  type_gte: Int
  cost: Int
  cost_not: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_gt: Int
  cost_gte: Int
  AND: [CivicScalarWhereInput!]
  OR: [CivicScalarWhereInput!]
  NOT: [CivicScalarWhereInput!]
}

type CivicSubscriptionPayload {
  mutation: MutationType!
  node: Civic
  updatedFields: [String!]
  previousValues: CivicPreviousValues
}

input CivicSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CivicWhereInput
  AND: [CivicSubscriptionWhereInput!]
}

input CivicUpdateDataInput {
  type: Int
  progress: FloatTSUpdateManyInput
  boosted: BooleanTSUpdateManyInput
  cost: Int
}

input CivicUpdateInput {
  type: Int
  progress: FloatTSUpdateManyInput
  boosted: BooleanTSUpdateManyInput
  cost: Int
}

input CivicUpdateManyDataInput {
  type: Int
  cost: Int
}

input CivicUpdateManyInput {
  create: [CivicCreateInput!]
  update: [CivicUpdateWithWhereUniqueNestedInput!]
  upsert: [CivicUpsertWithWhereUniqueNestedInput!]
  delete: [CivicWhereUniqueInput!]
  connect: [CivicWhereUniqueInput!]
  set: [CivicWhereUniqueInput!]
  disconnect: [CivicWhereUniqueInput!]
  deleteMany: [CivicScalarWhereInput!]
  updateMany: [CivicUpdateManyWithWhereNestedInput!]
}

input CivicUpdateManyMutationInput {
  type: Int
  cost: Int
}

input CivicUpdateManyWithWhereNestedInput {
  where: CivicScalarWhereInput!
  data: CivicUpdateManyDataInput!
}

input CivicUpdateWithWhereUniqueNestedInput {
  where: CivicWhereUniqueInput!
  data: CivicUpdateDataInput!
}

input CivicUpsertWithWhereUniqueNestedInput {
  where: CivicWhereUniqueInput!
  update: CivicUpdateDataInput!
  create: CivicCreateInput!
}

input CivicWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: Int
  type_not: Int
  type_in: [Int!]
  type_not_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_gt: Int
  type_gte: Int
  progress_some: FloatTSWhereInput
  progress_every: FloatTSRestrictedWhereInput
  progress_none: FloatTSRestrictedWhereInput
  boosted_some: BooleanTSWhereInput
  boosted_every: BooleanTSRestrictedWhereInput
  boosted_none: BooleanTSRestrictedWhereInput
  cost: Int
  cost_not: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_gt: Int
  cost_gte: Int
  AND: [CivicWhereInput!]
}

input CivicWhereUniqueInput {
  id: ID
}

scalar DateTime

type FloatTS {
  value: Float!
  time: DateTime!
}

input FloatTSCreateInput {
  value: Float!
}

input FloatTSCreateManyInput {
  create: [FloatTSCreateInput!]
}

input FloatTSRestrictedWhereInput {
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [FloatTSRestrictedWhereInput!]
}

input FloatTSScalarWhereInput {
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [FloatTSScalarWhereInput!]
  OR: [FloatTSScalarWhereInput!]
  NOT: [FloatTSScalarWhereInput!]
}

input FloatTSUpdateManyDataInput {
  value: Float
}

input FloatTSUpdateManyInput {
  create: [FloatTSCreateInput!]
  deleteMany: [FloatTSScalarWhereInput!]
  updateMany: [FloatTSUpdateManyWithWhereNestedInput!]
}

input FloatTSUpdateManyWithWhereNestedInput {
  where: FloatTSScalarWhereInput!
  data: FloatTSUpdateManyDataInput!
}

input FloatTSWhereInput {
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [FloatTSWhereInput!]
}

type Game {
  id: ID!
  name: String!
  leaders(where: LeaderWhereInput, orderBy: LeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Leader!]
  map: Map!
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]!
  aggregate: AggregateGame!
}

input GameCreateInput {
  id: ID
  name: String!
  leaders: LeaderCreateManyInput
  map: MapCreateOneInput!
}

type GameEdge {
  node: Game!
  cursor: String!
}

enum GameOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type GamePreviousValues {
  id: ID!
  name: String!
}

type GameSubscriptionPayload {
  mutation: MutationType!
  node: Game
  updatedFields: [String!]
  previousValues: GamePreviousValues
}

input GameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameWhereInput
  AND: [GameSubscriptionWhereInput!]
}

input GameUpdateInput {
  name: String
  leaders: LeaderUpdateManyInput
  map: MapUpdateOneRequiredInput
}

input GameUpdateManyMutationInput {
  name: String
}

input GameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  leaders_some: LeaderWhereInput
  map: MapWhereInput
  AND: [GameWhereInput!]
}

input GameWhereUniqueInput {
  id: ID
}

type IntTS {
  value: Int!
  time: DateTime!
}

input IntTSCreateInput {
  value: Int!
}

input IntTSCreateManyInput {
  create: [IntTSCreateInput!]
}

input IntTSRestrictedWhereInput {
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [IntTSRestrictedWhereInput!]
}

input IntTSScalarWhereInput {
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [IntTSScalarWhereInput!]
  OR: [IntTSScalarWhereInput!]
  NOT: [IntTSScalarWhereInput!]
}

input IntTSUpdateManyDataInput {
  value: Int
}

input IntTSUpdateManyInput {
  create: [IntTSCreateInput!]
  deleteMany: [IntTSScalarWhereInput!]
  updateMany: [IntTSUpdateManyWithWhereNestedInput!]
}

input IntTSUpdateManyWithWhereNestedInput {
  where: IntTSScalarWhereInput!
  data: IntTSUpdateManyDataInput!
}

input IntTSWhereInput {
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [IntTSWhereInput!]
}

type Leader {
  id: ID!
  name: String!
  player: Player!
  cities(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [City!]
  techs(where: TechWhereInput, orderBy: TechOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tech!]
  civics(where: CivicWhereInput, orderBy: CivicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Civic!]
  units(where: UnitWhereInput, orderBy: UnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Unit!]
}

type LeaderConnection {
  pageInfo: PageInfo!
  edges: [LeaderEdge]!
  aggregate: AggregateLeader!
}

input LeaderCreateInput {
  id: ID
  name: String!
  player: PlayerCreateOneInput!
  cities: CityCreateManyInput
  techs: TechCreateManyInput
  civics: CivicCreateManyInput
  units: UnitCreateManyInput
}

input LeaderCreateManyInput {
  create: [LeaderCreateInput!]
  connect: [LeaderWhereUniqueInput!]
}

type LeaderEdge {
  node: Leader!
  cursor: String!
}

enum LeaderOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type LeaderPreviousValues {
  id: ID!
  name: String!
}

input LeaderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [LeaderScalarWhereInput!]
  OR: [LeaderScalarWhereInput!]
  NOT: [LeaderScalarWhereInput!]
}

type LeaderSubscriptionPayload {
  mutation: MutationType!
  node: Leader
  updatedFields: [String!]
  previousValues: LeaderPreviousValues
}

input LeaderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LeaderWhereInput
  AND: [LeaderSubscriptionWhereInput!]
}

input LeaderUpdateDataInput {
  name: String
  player: PlayerUpdateOneRequiredInput
  cities: CityUpdateManyInput
  techs: TechUpdateManyInput
  civics: CivicUpdateManyInput
  units: UnitUpdateManyInput
}

input LeaderUpdateInput {
  name: String
  player: PlayerUpdateOneRequiredInput
  cities: CityUpdateManyInput
  techs: TechUpdateManyInput
  civics: CivicUpdateManyInput
  units: UnitUpdateManyInput
}

input LeaderUpdateManyDataInput {
  name: String
}

input LeaderUpdateManyInput {
  create: [LeaderCreateInput!]
  update: [LeaderUpdateWithWhereUniqueNestedInput!]
  upsert: [LeaderUpsertWithWhereUniqueNestedInput!]
  delete: [LeaderWhereUniqueInput!]
  connect: [LeaderWhereUniqueInput!]
  set: [LeaderWhereUniqueInput!]
  disconnect: [LeaderWhereUniqueInput!]
  deleteMany: [LeaderScalarWhereInput!]
  updateMany: [LeaderUpdateManyWithWhereNestedInput!]
}

input LeaderUpdateManyMutationInput {
  name: String
}

input LeaderUpdateManyWithWhereNestedInput {
  where: LeaderScalarWhereInput!
  data: LeaderUpdateManyDataInput!
}

input LeaderUpdateWithWhereUniqueNestedInput {
  where: LeaderWhereUniqueInput!
  data: LeaderUpdateDataInput!
}

input LeaderUpsertWithWhereUniqueNestedInput {
  where: LeaderWhereUniqueInput!
  update: LeaderUpdateDataInput!
  create: LeaderCreateInput!
}

input LeaderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  player: PlayerWhereInput
  cities_some: CityWhereInput
  techs_some: TechWhereInput
  civics_some: CivicWhereInput
  units_some: UnitWhereInput
  AND: [LeaderWhereInput!]
}

input LeaderWhereUniqueInput {
  id: ID
}

scalar Long

type Map {
  id: ID!
  type: String!
  tiles(where: TileWhereInput, orderBy: TileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tile!]
}

type MapConnection {
  pageInfo: PageInfo!
  edges: [MapEdge]!
  aggregate: AggregateMap!
}

input MapCreateInput {
  id: ID
  type: String!
  tiles: TileCreateManyInput
}

input MapCreateOneInput {
  create: MapCreateInput
  connect: MapWhereUniqueInput
}

type MapEdge {
  node: Map!
  cursor: String!
}

enum MapOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
}

type MapPreviousValues {
  id: ID!
  type: String!
}

type MapSubscriptionPayload {
  mutation: MutationType!
  node: Map
  updatedFields: [String!]
  previousValues: MapPreviousValues
}

input MapSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MapWhereInput
  AND: [MapSubscriptionWhereInput!]
}

input MapUpdateDataInput {
  type: String
  tiles: TileUpdateManyInput
}

input MapUpdateInput {
  type: String
  tiles: TileUpdateManyInput
}

input MapUpdateManyMutationInput {
  type: String
}

input MapUpdateOneRequiredInput {
  create: MapCreateInput
  update: MapUpdateDataInput
  upsert: MapUpsertNestedInput
  connect: MapWhereUniqueInput
}

input MapUpsertNestedInput {
  update: MapUpdateDataInput!
  create: MapCreateInput!
}

input MapWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  tiles_some: TileWhereInput
  AND: [MapWhereInput!]
}

input MapWhereUniqueInput {
  id: ID
}

type Mutation {
  createCity(data: CityCreateInput!): City!
  updateCity(data: CityUpdateInput!, where: CityWhereUniqueInput!): City
  upsertCity(where: CityWhereUniqueInput!, create: CityCreateInput!, update: CityUpdateInput!): City!
  deleteCity(where: CityWhereUniqueInput!): City
  deleteManyCities(where: CityWhereInput): BatchPayload!
  createCivic(data: CivicCreateInput!): Civic!
  updateCivic(data: CivicUpdateInput!, where: CivicWhereUniqueInput!): Civic
  updateManyCivics(data: CivicUpdateManyMutationInput!, where: CivicWhereInput): BatchPayload!
  upsertCivic(where: CivicWhereUniqueInput!, create: CivicCreateInput!, update: CivicUpdateInput!): Civic!
  deleteCivic(where: CivicWhereUniqueInput!): Civic
  deleteManyCivics(where: CivicWhereInput): BatchPayload!
  createGame(data: GameCreateInput!): Game!
  updateGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateManyGames(data: GameUpdateManyMutationInput!, where: GameWhereInput): BatchPayload!
  upsertGame(where: GameWhereUniqueInput!, create: GameCreateInput!, update: GameUpdateInput!): Game!
  deleteGame(where: GameWhereUniqueInput!): Game
  deleteManyGames(where: GameWhereInput): BatchPayload!
  createLeader(data: LeaderCreateInput!): Leader!
  updateLeader(data: LeaderUpdateInput!, where: LeaderWhereUniqueInput!): Leader
  updateManyLeaders(data: LeaderUpdateManyMutationInput!, where: LeaderWhereInput): BatchPayload!
  upsertLeader(where: LeaderWhereUniqueInput!, create: LeaderCreateInput!, update: LeaderUpdateInput!): Leader!
  deleteLeader(where: LeaderWhereUniqueInput!): Leader
  deleteManyLeaders(where: LeaderWhereInput): BatchPayload!
  createMap(data: MapCreateInput!): Map!
  updateMap(data: MapUpdateInput!, where: MapWhereUniqueInput!): Map
  updateManyMaps(data: MapUpdateManyMutationInput!, where: MapWhereInput): BatchPayload!
  upsertMap(where: MapWhereUniqueInput!, create: MapCreateInput!, update: MapUpdateInput!): Map!
  deleteMap(where: MapWhereUniqueInput!): Map
  deleteManyMaps(where: MapWhereInput): BatchPayload!
  createPlayer(data: PlayerCreateInput!): Player!
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  upsertPlayer(where: PlayerWhereUniqueInput!, create: PlayerCreateInput!, update: PlayerUpdateInput!): Player!
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  createTech(data: TechCreateInput!): Tech!
  updateTech(data: TechUpdateInput!, where: TechWhereUniqueInput!): Tech
  updateManyTeches(data: TechUpdateManyMutationInput!, where: TechWhereInput): BatchPayload!
  upsertTech(where: TechWhereUniqueInput!, create: TechCreateInput!, update: TechUpdateInput!): Tech!
  deleteTech(where: TechWhereUniqueInput!): Tech
  deleteManyTeches(where: TechWhereInput): BatchPayload!
  createTile(data: TileCreateInput!): Tile!
  updateTile(data: TileUpdateInput!, where: TileWhereUniqueInput!): Tile
  updateManyTiles(data: TileUpdateManyMutationInput!, where: TileWhereInput): BatchPayload!
  upsertTile(where: TileWhereUniqueInput!, create: TileCreateInput!, update: TileUpdateInput!): Tile!
  deleteTile(where: TileWhereUniqueInput!): Tile
  deleteManyTiles(where: TileWhereInput): BatchPayload!
  createUnit(data: UnitCreateInput!): Unit!
  updateUnit(data: UnitUpdateInput!, where: UnitWhereUniqueInput!): Unit
  updateManyUnits(data: UnitUpdateManyMutationInput!, where: UnitWhereInput): BatchPayload!
  upsertUnit(where: UnitWhereUniqueInput!, create: UnitCreateInput!, update: UnitUpdateInput!): Unit!
  deleteUnit(where: UnitWhereUniqueInput!): Unit
  deleteManyUnits(where: UnitWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  id: ID!
  name: [StringTS!]
  isHuman: [BooleanTS!]
}

type PlayerConnection {
  pageInfo: PageInfo!
  edges: [PlayerEdge]!
  aggregate: AggregatePlayer!
}

input PlayerCreateInput {
  id: ID
  name: StringTSCreateManyInput
  isHuman: BooleanTSCreateManyInput
}

input PlayerCreateOneInput {
  create: PlayerCreateInput
  connect: PlayerWhereUniqueInput
}

type PlayerEdge {
  node: Player!
  cursor: String!
}

enum PlayerOrderByInput {
  id_ASC
  id_DESC
}

type PlayerPreviousValues {
  id: ID!
}

type PlayerSubscriptionPayload {
  mutation: MutationType!
  node: Player
  updatedFields: [String!]
  previousValues: PlayerPreviousValues
}

input PlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerWhereInput
  AND: [PlayerSubscriptionWhereInput!]
}

input PlayerUpdateDataInput {
  name: StringTSUpdateManyInput
  isHuman: BooleanTSUpdateManyInput
}

input PlayerUpdateInput {
  name: StringTSUpdateManyInput
  isHuman: BooleanTSUpdateManyInput
}

input PlayerUpdateOneRequiredInput {
  create: PlayerCreateInput
  update: PlayerUpdateDataInput
  upsert: PlayerUpsertNestedInput
  connect: PlayerWhereUniqueInput
}

input PlayerUpsertNestedInput {
  update: PlayerUpdateDataInput!
  create: PlayerCreateInput!
}

input PlayerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name_some: StringTSWhereInput
  name_every: StringTSRestrictedWhereInput
  name_none: StringTSRestrictedWhereInput
  isHuman_some: BooleanTSWhereInput
  isHuman_every: BooleanTSRestrictedWhereInput
  isHuman_none: BooleanTSRestrictedWhereInput
  AND: [PlayerWhereInput!]
}

input PlayerWhereUniqueInput {
  id: ID
}

type Query {
  city(where: CityWhereUniqueInput!): City
  cities(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [City]!
  citiesConnection(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CityConnection!
  civic(where: CivicWhereUniqueInput!): Civic
  civics(where: CivicWhereInput, orderBy: CivicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Civic]!
  civicsConnection(where: CivicWhereInput, orderBy: CivicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CivicConnection!
  game(where: GameWhereUniqueInput!): Game
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game]!
  gamesConnection(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameConnection!
  leader(where: LeaderWhereUniqueInput!): Leader
  leaders(where: LeaderWhereInput, orderBy: LeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Leader]!
  leadersConnection(where: LeaderWhereInput, orderBy: LeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LeaderConnection!
  map(where: MapWhereUniqueInput!): Map
  maps(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map]!
  mapsConnection(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MapConnection!
  player(where: PlayerWhereUniqueInput!): Player
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player]!
  playersConnection(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerConnection!
  tech(where: TechWhereUniqueInput!): Tech
  teches(where: TechWhereInput, orderBy: TechOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tech]!
  techesConnection(where: TechWhereInput, orderBy: TechOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TechConnection!
  tile(where: TileWhereUniqueInput!): Tile
  tiles(where: TileWhereInput, orderBy: TileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tile]!
  tilesConnection(where: TileWhereInput, orderBy: TileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TileConnection!
  unit(where: UnitWhereUniqueInput!): Unit
  units(where: UnitWhereInput, orderBy: UnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Unit]!
  unitsConnection(where: UnitWhereInput, orderBy: UnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UnitConnection!
  node(id: ID!): Node
}

type StringTS {
  value: String!
  time: DateTime!
}

input StringTSCreateInput {
  value: String!
}

input StringTSCreateManyInput {
  create: [StringTSCreateInput!]
}

input StringTSRestrictedWhereInput {
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [StringTSRestrictedWhereInput!]
}

input StringTSScalarWhereInput {
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [StringTSScalarWhereInput!]
  OR: [StringTSScalarWhereInput!]
  NOT: [StringTSScalarWhereInput!]
}

input StringTSUpdateManyDataInput {
  value: String
}

input StringTSUpdateManyInput {
  create: [StringTSCreateInput!]
  deleteMany: [StringTSScalarWhereInput!]
  updateMany: [StringTSUpdateManyWithWhereNestedInput!]
}

input StringTSUpdateManyWithWhereNestedInput {
  where: StringTSScalarWhereInput!
  data: StringTSUpdateManyDataInput!
}

input StringTSWhereInput {
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [StringTSWhereInput!]
}

type Subscription {
  city(where: CitySubscriptionWhereInput): CitySubscriptionPayload
  civic(where: CivicSubscriptionWhereInput): CivicSubscriptionPayload
  game(where: GameSubscriptionWhereInput): GameSubscriptionPayload
  leader(where: LeaderSubscriptionWhereInput): LeaderSubscriptionPayload
  map(where: MapSubscriptionWhereInput): MapSubscriptionPayload
  player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
  tech(where: TechSubscriptionWhereInput): TechSubscriptionPayload
  tile(where: TileSubscriptionWhereInput): TileSubscriptionPayload
  unit(where: UnitSubscriptionWhereInput): UnitSubscriptionPayload
}

type Tech {
  id: ID!
  type: Int!
  progress: [FloatTS!]
  boosted: [BooleanTS!]
  cost: Int!
}

type TechConnection {
  pageInfo: PageInfo!
  edges: [TechEdge]!
  aggregate: AggregateTech!
}

input TechCreateInput {
  id: ID
  type: Int!
  progress: FloatTSCreateManyInput
  boosted: BooleanTSCreateManyInput
  cost: Int!
}

input TechCreateManyInput {
  create: [TechCreateInput!]
  connect: [TechWhereUniqueInput!]
}

type TechEdge {
  node: Tech!
  cursor: String!
}

enum TechOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  cost_ASC
  cost_DESC
}

type TechPreviousValues {
  id: ID!
  type: Int!
  cost: Int!
}

input TechScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: Int
  type_not: Int
  type_in: [Int!]
  type_not_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_gt: Int
  type_gte: Int
  cost: Int
  cost_not: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_gt: Int
  cost_gte: Int
  AND: [TechScalarWhereInput!]
  OR: [TechScalarWhereInput!]
  NOT: [TechScalarWhereInput!]
}

type TechSubscriptionPayload {
  mutation: MutationType!
  node: Tech
  updatedFields: [String!]
  previousValues: TechPreviousValues
}

input TechSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TechWhereInput
  AND: [TechSubscriptionWhereInput!]
}

input TechUpdateDataInput {
  type: Int
  progress: FloatTSUpdateManyInput
  boosted: BooleanTSUpdateManyInput
  cost: Int
}

input TechUpdateInput {
  type: Int
  progress: FloatTSUpdateManyInput
  boosted: BooleanTSUpdateManyInput
  cost: Int
}

input TechUpdateManyDataInput {
  type: Int
  cost: Int
}

input TechUpdateManyInput {
  create: [TechCreateInput!]
  update: [TechUpdateWithWhereUniqueNestedInput!]
  upsert: [TechUpsertWithWhereUniqueNestedInput!]
  delete: [TechWhereUniqueInput!]
  connect: [TechWhereUniqueInput!]
  set: [TechWhereUniqueInput!]
  disconnect: [TechWhereUniqueInput!]
  deleteMany: [TechScalarWhereInput!]
  updateMany: [TechUpdateManyWithWhereNestedInput!]
}

input TechUpdateManyMutationInput {
  type: Int
  cost: Int
}

input TechUpdateManyWithWhereNestedInput {
  where: TechScalarWhereInput!
  data: TechUpdateManyDataInput!
}

input TechUpdateWithWhereUniqueNestedInput {
  where: TechWhereUniqueInput!
  data: TechUpdateDataInput!
}

input TechUpsertWithWhereUniqueNestedInput {
  where: TechWhereUniqueInput!
  update: TechUpdateDataInput!
  create: TechCreateInput!
}

input TechWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: Int
  type_not: Int
  type_in: [Int!]
  type_not_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_gt: Int
  type_gte: Int
  progress_some: FloatTSWhereInput
  progress_every: FloatTSRestrictedWhereInput
  progress_none: FloatTSRestrictedWhereInput
  boosted_some: BooleanTSWhereInput
  boosted_every: BooleanTSRestrictedWhereInput
  boosted_none: BooleanTSRestrictedWhereInput
  cost: Int
  cost_not: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_gt: Int
  cost_gte: Int
  AND: [TechWhereInput!]
}

input TechWhereUniqueInput {
  id: ID
}

type Tile {
  id: ID!
  location: [Int!]!
  terrain: [IntTS!]
  feature: [IntTS!]
}

type TileConnection {
  pageInfo: PageInfo!
  edges: [TileEdge]!
  aggregate: AggregateTile!
}

input TileCreateInput {
  id: ID
  location: TileCreatelocationInput
  terrain: IntTSCreateManyInput
  feature: IntTSCreateManyInput
}

input TileCreatelocationInput {
  set: [Int!]
}

input TileCreateManyInput {
  create: [TileCreateInput!]
  connect: [TileWhereUniqueInput!]
}

input TileCreateOneInput {
  create: TileCreateInput
  connect: TileWhereUniqueInput
}

type TileEdge {
  node: Tile!
  cursor: String!
}

enum TileOrderByInput {
  id_ASC
  id_DESC
}

type TilePreviousValues {
  id: ID!
  location: [Int!]!
}

input TileScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [TileScalarWhereInput!]
  OR: [TileScalarWhereInput!]
  NOT: [TileScalarWhereInput!]
}

type TileSubscriptionPayload {
  mutation: MutationType!
  node: Tile
  updatedFields: [String!]
  previousValues: TilePreviousValues
}

input TileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TileWhereInput
  AND: [TileSubscriptionWhereInput!]
}

type TileTS {
  value: Tile!
  time: DateTime!
}

input TileTSCreateInput {
  value: TileCreateOneInput!
}

input TileTSCreateManyInput {
  create: [TileTSCreateInput!]
}

input TileTSRestrictedWhereInput {
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [TileTSRestrictedWhereInput!]
}

input TileTSScalarWhereInput {
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [TileTSScalarWhereInput!]
  OR: [TileTSScalarWhereInput!]
  NOT: [TileTSScalarWhereInput!]
}

input TileTSUpdateManyInput {
  create: [TileTSCreateInput!]
  deleteMany: [TileTSScalarWhereInput!]
}

input TileTSWhereInput {
  value: TileWhereInput
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  AND: [TileTSWhereInput!]
}

input TileUpdateDataInput {
  location: TileUpdatelocationInput
  terrain: IntTSUpdateManyInput
  feature: IntTSUpdateManyInput
}

input TileUpdateInput {
  location: TileUpdatelocationInput
  terrain: IntTSUpdateManyInput
  feature: IntTSUpdateManyInput
}

input TileUpdatelocationInput {
  set: [Int!]
}

input TileUpdateManyDataInput {
  location: TileUpdatelocationInput
}

input TileUpdateManyInput {
  create: [TileCreateInput!]
  update: [TileUpdateWithWhereUniqueNestedInput!]
  upsert: [TileUpsertWithWhereUniqueNestedInput!]
  delete: [TileWhereUniqueInput!]
  connect: [TileWhereUniqueInput!]
  set: [TileWhereUniqueInput!]
  disconnect: [TileWhereUniqueInput!]
  deleteMany: [TileScalarWhereInput!]
  updateMany: [TileUpdateManyWithWhereNestedInput!]
}

input TileUpdateManyMutationInput {
  location: TileUpdatelocationInput
}

input TileUpdateManyWithWhereNestedInput {
  where: TileScalarWhereInput!
  data: TileUpdateManyDataInput!
}

input TileUpdateWithWhereUniqueNestedInput {
  where: TileWhereUniqueInput!
  data: TileUpdateDataInput!
}

input TileUpsertWithWhereUniqueNestedInput {
  where: TileWhereUniqueInput!
  update: TileUpdateDataInput!
  create: TileCreateInput!
}

input TileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  terrain_some: IntTSWhereInput
  terrain_every: IntTSRestrictedWhereInput
  terrain_none: IntTSRestrictedWhereInput
  feature_some: IntTSWhereInput
  feature_every: IntTSRestrictedWhereInput
  feature_none: IntTSRestrictedWhereInput
  AND: [TileWhereInput!]
}

input TileWhereUniqueInput {
  id: ID
}

type Unit {
  id: ID!
  type: Int!
  location: [TileTS!]
  cost: Int!
  baseMoves: Int
  combat: Int
  range: Int
  rangedCombar: Int
  bombard: Int
}

type UnitConnection {
  pageInfo: PageInfo!
  edges: [UnitEdge]!
  aggregate: AggregateUnit!
}

input UnitCreateInput {
  id: ID
  type: Int!
  location: TileTSCreateManyInput
  cost: Int!
  baseMoves: Int
  combat: Int
  range: Int
  rangedCombar: Int
  bombard: Int
}

input UnitCreateManyInput {
  create: [UnitCreateInput!]
  connect: [UnitWhereUniqueInput!]
}

type UnitEdge {
  node: Unit!
  cursor: String!
}

enum UnitOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  cost_ASC
  cost_DESC
  baseMoves_ASC
  baseMoves_DESC
  combat_ASC
  combat_DESC
  range_ASC
  range_DESC
  rangedCombar_ASC
  rangedCombar_DESC
  bombard_ASC
  bombard_DESC
}

type UnitPreviousValues {
  id: ID!
  type: Int!
  cost: Int!
  baseMoves: Int
  combat: Int
  range: Int
  rangedCombar: Int
  bombard: Int
}

input UnitScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: Int
  type_not: Int
  type_in: [Int!]
  type_not_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_gt: Int
  type_gte: Int
  cost: Int
  cost_not: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_gt: Int
  cost_gte: Int
  baseMoves: Int
  baseMoves_not: Int
  baseMoves_in: [Int!]
  baseMoves_not_in: [Int!]
  baseMoves_lt: Int
  baseMoves_lte: Int
  baseMoves_gt: Int
  baseMoves_gte: Int
  combat: Int
  combat_not: Int
  combat_in: [Int!]
  combat_not_in: [Int!]
  combat_lt: Int
  combat_lte: Int
  combat_gt: Int
  combat_gte: Int
  range: Int
  range_not: Int
  range_in: [Int!]
  range_not_in: [Int!]
  range_lt: Int
  range_lte: Int
  range_gt: Int
  range_gte: Int
  rangedCombar: Int
  rangedCombar_not: Int
  rangedCombar_in: [Int!]
  rangedCombar_not_in: [Int!]
  rangedCombar_lt: Int
  rangedCombar_lte: Int
  rangedCombar_gt: Int
  rangedCombar_gte: Int
  bombard: Int
  bombard_not: Int
  bombard_in: [Int!]
  bombard_not_in: [Int!]
  bombard_lt: Int
  bombard_lte: Int
  bombard_gt: Int
  bombard_gte: Int
  AND: [UnitScalarWhereInput!]
  OR: [UnitScalarWhereInput!]
  NOT: [UnitScalarWhereInput!]
}

type UnitSubscriptionPayload {
  mutation: MutationType!
  node: Unit
  updatedFields: [String!]
  previousValues: UnitPreviousValues
}

input UnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UnitWhereInput
  AND: [UnitSubscriptionWhereInput!]
}

input UnitUpdateDataInput {
  type: Int
  location: TileTSUpdateManyInput
  cost: Int
  baseMoves: Int
  combat: Int
  range: Int
  rangedCombar: Int
  bombard: Int
}

input UnitUpdateInput {
  type: Int
  location: TileTSUpdateManyInput
  cost: Int
  baseMoves: Int
  combat: Int
  range: Int
  rangedCombar: Int
  bombard: Int
}

input UnitUpdateManyDataInput {
  type: Int
  cost: Int
  baseMoves: Int
  combat: Int
  range: Int
  rangedCombar: Int
  bombard: Int
}

input UnitUpdateManyInput {
  create: [UnitCreateInput!]
  update: [UnitUpdateWithWhereUniqueNestedInput!]
  upsert: [UnitUpsertWithWhereUniqueNestedInput!]
  delete: [UnitWhereUniqueInput!]
  connect: [UnitWhereUniqueInput!]
  set: [UnitWhereUniqueInput!]
  disconnect: [UnitWhereUniqueInput!]
  deleteMany: [UnitScalarWhereInput!]
  updateMany: [UnitUpdateManyWithWhereNestedInput!]
}

input UnitUpdateManyMutationInput {
  type: Int
  cost: Int
  baseMoves: Int
  combat: Int
  range: Int
  rangedCombar: Int
  bombard: Int
}

input UnitUpdateManyWithWhereNestedInput {
  where: UnitScalarWhereInput!
  data: UnitUpdateManyDataInput!
}

input UnitUpdateWithWhereUniqueNestedInput {
  where: UnitWhereUniqueInput!
  data: UnitUpdateDataInput!
}

input UnitUpsertWithWhereUniqueNestedInput {
  where: UnitWhereUniqueInput!
  update: UnitUpdateDataInput!
  create: UnitCreateInput!
}

input UnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: Int
  type_not: Int
  type_in: [Int!]
  type_not_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_gt: Int
  type_gte: Int
  location_some: TileTSWhereInput
  location_every: TileTSRestrictedWhereInput
  location_none: TileTSRestrictedWhereInput
  cost: Int
  cost_not: Int
  cost_in: [Int!]
  cost_not_in: [Int!]
  cost_lt: Int
  cost_lte: Int
  cost_gt: Int
  cost_gte: Int
  baseMoves: Int
  baseMoves_not: Int
  baseMoves_in: [Int!]
  baseMoves_not_in: [Int!]
  baseMoves_lt: Int
  baseMoves_lte: Int
  baseMoves_gt: Int
  baseMoves_gte: Int
  combat: Int
  combat_not: Int
  combat_in: [Int!]
  combat_not_in: [Int!]
  combat_lt: Int
  combat_lte: Int
  combat_gt: Int
  combat_gte: Int
  range: Int
  range_not: Int
  range_in: [Int!]
  range_not_in: [Int!]
  range_lt: Int
  range_lte: Int
  range_gt: Int
  range_gte: Int
  rangedCombar: Int
  rangedCombar_not: Int
  rangedCombar_in: [Int!]
  rangedCombar_not_in: [Int!]
  rangedCombar_lt: Int
  rangedCombar_lte: Int
  rangedCombar_gt: Int
  rangedCombar_gte: Int
  bombard: Int
  bombard_not: Int
  bombard_in: [Int!]
  bombard_not_in: [Int!]
  bombard_lt: Int
  bombard_lte: Int
  bombard_gt: Int
  bombard_gte: Int
  AND: [UnitWhereInput!]
}

input UnitWhereUniqueInput {
  id: ID
}
`